<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Operating System | Notev</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/favicon152.png">
    <link rel="mask-icon" href="/icons/favicon152.png" color="#3eaf7c">
    <link rel="alternate" type="application/rss+xml" href="https://www.sigure.xyz/rss.xml" title="Notev RSS Feed">
    <link rel="alternate" type="application/atom+xml" href="https://www.sigure.xyz/feed.atom" title="Notev Atom Feed">
    <link rel="alternate" type="application/json" href="https://www.sigure.xyz/feed.json" title="Notev JSON Feed">
    <meta name="description" content="一个小透明的透明世界">
    <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
    <meta property="og:image" content="/sigure_mo.png">
    <meta name="theme-color" content="#222222">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icons/favicon144.png">
    <meta name="msapplication-TileColor" content="#000000">
    <link rel="preload" href="/assets/css/0.styles.4b4222a6.css" as="style"><link rel="preload" href="/assets/js/app.c177b168.js" as="script"><link rel="preload" href="/assets/js/20.880cff98.js" as="script"><link rel="preload" href="/assets/js/6.b268b72c.js" as="script"><link rel="preload" href="/assets/js/18.f17d4fe5.js" as="script"><link rel="prefetch" href="/assets/js/1.5267eebb.js"><link rel="prefetch" href="/assets/js/10.92e08c9b.js"><link rel="prefetch" href="/assets/js/11.2f9f0eb6.js"><link rel="prefetch" href="/assets/js/12.994c916b.js"><link rel="prefetch" href="/assets/js/13.0fd5126a.js"><link rel="prefetch" href="/assets/js/14.11d4ee66.js"><link rel="prefetch" href="/assets/js/15.063e05e7.js"><link rel="prefetch" href="/assets/js/16.f6d10b3f.js"><link rel="prefetch" href="/assets/js/17.55a100e5.js"><link rel="prefetch" href="/assets/js/19.082c2eab.js"><link rel="prefetch" href="/assets/js/21.3ef622d5.js"><link rel="prefetch" href="/assets/js/22.cb63dd25.js"><link rel="prefetch" href="/assets/js/23.d815a65e.js"><link rel="prefetch" href="/assets/js/24.f7fe6d98.js"><link rel="prefetch" href="/assets/js/25.79e2532f.js"><link rel="prefetch" href="/assets/js/26.76cf8661.js"><link rel="prefetch" href="/assets/js/27.4949f560.js"><link rel="prefetch" href="/assets/js/28.403f9c78.js"><link rel="prefetch" href="/assets/js/29.08e5e0b0.js"><link rel="prefetch" href="/assets/js/30.27337d55.js"><link rel="prefetch" href="/assets/js/31.62cacced.js"><link rel="prefetch" href="/assets/js/32.7a9b548a.js"><link rel="prefetch" href="/assets/js/33.2d4b9433.js"><link rel="prefetch" href="/assets/js/34.67c941d1.js"><link rel="prefetch" href="/assets/js/35.08d8af35.js"><link rel="prefetch" href="/assets/js/36.fe82c24a.js"><link rel="prefetch" href="/assets/js/37.7e280ef8.js"><link rel="prefetch" href="/assets/js/38.e945d1a8.js"><link rel="prefetch" href="/assets/js/39.1ce1195c.js"><link rel="prefetch" href="/assets/js/4.69bbbe05.js"><link rel="prefetch" href="/assets/js/40.1d207a88.js"><link rel="prefetch" href="/assets/js/41.3f684380.js"><link rel="prefetch" href="/assets/js/42.0a38acc2.js"><link rel="prefetch" href="/assets/js/43.5e82c9e1.js"><link rel="prefetch" href="/assets/js/44.998a3155.js"><link rel="prefetch" href="/assets/js/45.875fdc37.js"><link rel="prefetch" href="/assets/js/46.678ccfea.js"><link rel="prefetch" href="/assets/js/47.cc038a52.js"><link rel="prefetch" href="/assets/js/48.8655d2e7.js"><link rel="prefetch" href="/assets/js/49.1b1b13ad.js"><link rel="prefetch" href="/assets/js/5.20f71a3e.js"><link rel="prefetch" href="/assets/js/50.7ef4cfe5.js"><link rel="prefetch" href="/assets/js/51.b0435786.js"><link rel="prefetch" href="/assets/js/52.9e4c5a3d.js"><link rel="prefetch" href="/assets/js/53.3f260d31.js"><link rel="prefetch" href="/assets/js/54.3fa853a2.js"><link rel="prefetch" href="/assets/js/7.c241ed5c.js"><link rel="prefetch" href="/assets/js/8.1c4f9d84.js"><link rel="prefetch" href="/assets/js/9.62b5cda8.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.ca76c415.js">
    <link rel="stylesheet" href="/assets/css/0.styles.4b4222a6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-meteorlxy"><header class="header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/bg.jpg);" data-v-7a046aea><div data-v-e4145d0a data-v-7a046aea><nav class="navbar" data-v-e4145d0a><div class="container" data-v-e4145d0a><a href="/" class="router-link-active" data-v-e4145d0a><span class="navbar-site-name" data-v-e4145d0a>
          Notev
        </span></a> <div class="navbar-toggler" data-v-e4145d0a><svg class="icon" style="font-size:1.2em;" data-v-e4145d0a data-v-e4145d0a><title data-v-e4145d0a data-v-e4145d0a>menu</title><use xlink:href="#icon-menu" data-v-e4145d0a data-v-e4145d0a></use></svg></div> <div class="navbar-links" data-v-e4145d0a><a href="/" class="navbar-link" data-v-e4145d0a>
            Home
          </a><a href="/posts/" class="navbar-link router-link-active" data-v-e4145d0a>
            Posts
          </a><a href="/about.html" class="navbar-link" data-v-e4145d0a>
            About
          </a><a href="https://github.com/SigureMo/notev" target="_blank" rel="noopener noreferrer" class="navbar-link" data-v-e4145d0a><span data-v-e4145d0a>Github</span> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound" data-v-e4145d0a data-v-e4145d0a><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-e4145d0a></div></div> <div class="banner" data-v-98d6aa8c data-v-7a046aea data-v-7a046aea><div class="container" data-v-98d6aa8c><div class="center" data-v-98d6aa8c><h1 data-v-98d6aa8c data-v-7a046aea>
          Operating System
        </h1></div></div></div></header> <div class="container clearfix show-aside" data-v-4dd605a1 data-v-4dd605a1><main class="main" data-v-4dd605a1><div class="post" data-v-4dd605a1 data-v-4dd605a1><section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      Created : 2019-02-28
    </span> <span class="update-date" data-v-4e23451f>
      Updated : 2020-05-18
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2018/11/21/solid-state-phase-transformation.html" class="post-link" data-v-4e23451f>
      Previous Post : Solid-state Phase Transformation
    </a> <a href="/posts/2019/04/25/discrete-mathematics.html" class="post-link" data-v-4e23451f>
      Next Post : Discrete Mathematics
    </a></section></section> <article class="main-div"><div class="post-content content content__default"><div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>《计算机操作系统》课程笔记</p></div> <h2 id="_1-操作系统引论"><a href="#_1-操作系统引论" class="header-anchor">#</a> 1 操作系统引论</h2> <p>配置在计算机硬件上的第一层软件</p> <h3 id="_1-1-操作系统的目标和作用"><a href="#_1-1-操作系统的目标和作用" class="header-anchor">#</a> 1.1 操作系统的目标和作用</h3> <h4 id="_1-1-1-操作系统的目标"><a href="#_1-1-1-操作系统的目标" class="header-anchor">#</a> 1.1.1 操作系统的目标</h4> <ul><li>方便性 避免用户书写机器语言</li> <li>有效性 防止大部分设备处于空闲状态，在操作系统的调度下各部分的协调恰如其分</li> <li>可扩充性 能方便地增添新的功能和模块</li> <li>开放性 按照某些标准开发，以便软硬件的兼容等等</li></ul> <h4 id="_1-1-2-操作系统的作用"><a href="#_1-1-2-操作系统的作用" class="header-anchor">#</a> 1.1.2 操作系统的作用</h4> <ul><li><p>OS 作为用户与计算机硬件系统之间的接口</p> <p><img src="/assets/img/OS01.2ab793b1.png" alt="OS01"></p></li> <li><p>OS 作为计算机系统资源的管理者</p> <ul><li>处理器上可执行的指令分为
<ul><li>特权指令</li> <li>非特权指令</li></ul></li> <li>处理器状态划分为
<ul><li>管态（管理态）</li> <li>目态（用户态）</li></ul></li></ul> <blockquote><p>处理器状态保证了特权指令的正确使用，把 OS 与用户程序区别开来</p></blockquote></li> <li><p>OS 实现了对计算机资源的抽象</p></li></ul> <h4 id="_1-1-3-推动操作系统发展的主要动力"><a href="#_1-1-3-推动操作系统发展的主要动力" class="header-anchor">#</a> 1.1.3 推动操作系统发展的主要动力</h4> <ul><li>不断提高计算机资源利用率</li> <li>方便用户</li> <li>器件的不断更新换代</li> <li>计算机体系结构的不断发展</li> <li>不断提出新的应用要求</li></ul> <h3 id="_1-2-操作系统的发展过程"><a href="#_1-2-操作系统的发展过程" class="header-anchor">#</a> 1.2 操作系统的发展过程</h3> <h4 id="_1-2-1-未配置操作系统的计算机系统"><a href="#_1-2-1-未配置操作系统的计算机系统" class="header-anchor">#</a> 1.2.1 未配置操作系统的计算机系统</h4> <ol><li><p>人工操作方式</p> <p>人工装填纸带，CPU 大多数时间在等待，浪费了大量的资源</p></li> <li><p>脱机输入/输出（Off-Line I/O）方式</p> <p>在手工与 CPU 之间加上了一个磁带，以优化 I/O 与 CPU 速度不匹配的问题</p></li></ol> <h4 id="_1-2-2-单道批处理系统"><a href="#_1-2-2-单道批处理系统" class="header-anchor">#</a> 1.2.2 单道批处理系统</h4> <ul><li><p>单道批处理系统（Simple Batch Processing System）的处理过程</p> <p>用监督程序来解放装填纸带人员的双手，并进一步解决了 I/O 与 CPU 之间速度不匹配的问题</p></li> <li><p>单道批处理系统的特征</p> <ul><li>单道性 内存中仅有一道程序运行</li> <li>自动性</li> <li>顺序性</li></ul></li></ul> <h4 id="_1-2-3-多道批处理系统"><a href="#_1-2-3-多道批处理系统" class="header-anchor">#</a> 1.2.3 多道批处理系统</h4> <ul><li><p>多道程序设计的基本概念</p> <p>用户提交的作业形成队列，按一定算法将若干作业调入内存</p></li> <li><p>多道程序设计的优点</p> <ul><li>提高 CPU 利用率</li> <li>提高内存和 I/O 设备利用率</li> <li>增加系统吞吐量</li></ul></li> <li><p>多道程序设计的缺点</p> <ul><li>平均周转时间长</li> <li>依然无交互能力</li></ul></li></ul> <h4 id="_1-2-4-分时系统"><a href="#_1-2-4-分时系统" class="header-anchor">#</a> 1.2.4 分时系统</h4> <ul><li><p>分时系统产生的动力</p> <ul><li>人们亟需可以实现<strong>人机交互</strong>的处理机以便调试运行程序</li> <li><strong>共享主机</strong></li></ul></li> <li><p>分时系统实现中的关键问题</p> <ul><li>及时接收 及时接收各个用户终端的输入</li> <li>及时处理 及时处理用户键入的命令</li></ul></li></ul> <p>=&gt; 分时系统，将 CPU 的时间分片，每个作业每次只能运行一个时间片</p> <ul><li><p>分时系统的特征</p> <ul><li>多路性</li> <li>独立性 每个人都好像独占资源</li> <li>及时性</li> <li>交互性</li></ul></li></ul> <h4 id="_1-2-5-实时系统"><a href="#_1-2-5-实时系统" class="header-anchor">#</a> 1.2.5 实时系统</h4> <ul><li><p>需求</p> <ul><li>实时控制</li> <li>实时信息处理</li></ul></li> <li><p>实时任务</p> <ul><li>按任务执行时是否呈现周期性来划分
<ul><li>周期性实时任务</li> <li>非周期性实时任务</li></ul></li> <li>根据对截止时间的要求来划分
<ul><li>硬实时任务</li> <li>软实时任务</li></ul></li></ul></li> <li><p>实时系统与分时系统特征的比较</p> <ul><li>多路性</li> <li>独立性</li> <li>交互性</li> <li>及时性</li> <li>可靠性</li></ul></li></ul> <h4 id="_1-2-6-微机操作系统的发展"><a href="#_1-2-6-微机操作系统的发展" class="header-anchor">#</a> 1.2.6 微机操作系统的发展</h4> <ol><li><p>单用户单任务操作系统</p> <ul><li>CP/M</li> <li>MS-DOS</li></ul></li> <li><p>单用户多任务操作系统</p> <p>各种 Windows</p></li> <li><p>多用户多任务操作系统</p> <p>UNIX</p> <ul><li>Solaris</li> <li>Linux ❤️</li></ul></li></ol> <h4 id="_1-2-7-其它操作系统"><a href="#_1-2-7-其它操作系统" class="header-anchor">#</a> 1.2.7 其它操作系统</h4> <ul><li>网络操作系统</li> <li>分布式操作系统 可独立也可协同，对用户来说相当于一个操作系统</li> <li>嵌入式操作系统</li></ul> <h3 id="_1-3-操作系统的特征"><a href="#_1-3-操作系统的特征" class="header-anchor">#</a> 1.3 操作系统的特征</h3> <h4 id="_1-3-1-并发性"><a href="#_1-3-1-并发性" class="header-anchor">#</a> 1.3.1 并发性</h4> <p>并行和并发的区别，组原就有提到，并行是真的多处理器处理多数据，并发是利用时分技术实现的，其微观本质上还是串行</p> <p>为了实现并发，引入了进程的概念，其<strong>作为资源分配的基本单位，可在系统中能独立运行</strong></p> <p>为了进一步提高并发程度，在进程内引入了线程，其<strong>作为独立运行和独立调度的基本单位，并不会拥有系统资源，开销就会小很多</strong></p> <h4 id="_1-3-2-共享性"><a href="#_1-3-2-共享性" class="header-anchor">#</a> 1.3.2 共享性</h4> <ul><li><p>互斥共享技术</p> <p>保证各个进程之间不会混淆</p></li> <li><p>同时访问方式</p> <p>各个进程可以同时访问同一个设备，比如磁盘</p></li></ul> <h4 id="_1-3-3-虚拟技术"><a href="#_1-3-3-虚拟技术" class="header-anchor">#</a> 1.3.3 虚拟技术</h4> <ul><li>时分复用技术
<ul><li>虚拟处理机技术</li> <li>虚拟设备技术</li></ul></li> <li>空分复用技术
<ul><li>虚拟磁盘技术 磁盘分区</li> <li>虚拟存储器技术</li></ul></li></ul> <h4 id="_1-3-4-异步性"><a href="#_1-3-4-异步性" class="header-anchor">#</a> 1.3.4 异步性</h4> <p>各个进程停停走走……</p> <h3 id="_1-4-操作系统的五大功能"><a href="#_1-4-操作系统的五大功能" class="header-anchor">#</a> 1.4 操作系统的五大功能</h3> <h4 id="_1-4-1-处理机管理"><a href="#_1-4-1-处理机管理" class="header-anchor">#</a> 1.4.1 处理机管理</h4> <ul><li>进程控制</li> <li>进程同步</li> <li>进程通信</li> <li>调度</li></ul> <h4 id="_1-4-2-存储器管理功能"><a href="#_1-4-2-存储器管理功能" class="header-anchor">#</a> 1.4.2 存储器管理功能</h4> <ul><li>内存分配</li> <li>内存保护</li> <li>地址映射</li> <li>内存扩充</li></ul> <h4 id="_1-4-3-设备管理功能"><a href="#_1-4-3-设备管理功能" class="header-anchor">#</a> 1.4.3 设备管理功能</h4> <ul><li>缓存管理</li> <li>设备分配</li> <li>设备处理</li></ul> <h4 id="_1-4-4-文件管理功能"><a href="#_1-4-4-文件管理功能" class="header-anchor">#</a> 1.4.4 文件管理功能</h4> <ul><li>文件存储空间的管理</li> <li>目录管理</li> <li>文件的读/写管理和保护</li></ul> <h4 id="_1-4-5-操作系统与用户之间的接口"><a href="#_1-4-5-操作系统与用户之间的接口" class="header-anchor">#</a> 1.4.5 操作系统与用户之间的接口</h4> <ul><li>用户接口</li> <li>程序接口</li></ul> <h4 id="_1-4-6-现代操作系统的新功能"><a href="#_1-4-6-现代操作系统的新功能" class="header-anchor">#</a> 1.4.6 现代操作系统的新功能</h4> <ul><li>系统安全</li> <li>网络的功能和服务</li> <li>支持多媒体</li></ul> <h3 id="_1-5-os-结构设计"><a href="#_1-5-os-结构设计" class="header-anchor">#</a> 1.5 OS 结构设计</h3> <h4 id="_1-5-1-传统的操作系统结构"><a href="#_1-5-1-传统的操作系统结构" class="header-anchor">#</a> 1.5.1 传统的操作系统结构</h4> <ol><li>无结构操作系统</li> <li>模块化结构操作系统 分解成一个一个模块</li> <li>分层式结构 OS 有序分层</li></ol> <h4 id="_1-5-2-客户-服务器（c-s）模式简介"><a href="#_1-5-2-客户-服务器（c-s）模式简介" class="header-anchor">#</a> 1.5.2 客户/服务器（C/S）模式简介</h4> <p>便于集中管理，但会有瓶颈问题和不可靠性</p> <h4 id="_1-5-3-面向对象的程序设计（oop）简介"><a href="#_1-5-3-面向对象的程序设计（oop）简介" class="header-anchor">#</a> 1.5.3 面向对象的程序设计（OOP）简介</h4> <h4 id="_1-5-4-微内核-os-结构"><a href="#_1-5-4-微内核-os-结构" class="header-anchor">#</a> 1.5.4 微内核 OS 结构</h4> <ul><li><p>足够小的内核</p> <p>将操作系统中最基本的部分放入微内核，其他部分放在外面作为服务器</p></li> <li><p>基于 C/S 模式</p> <p><img src="/assets/img/OS02.ce6e3f33.png" alt="OS02"></p></li> <li><p>应用”机制与策略分离“原理</p></li> <li><p>采用面向对象技术</p></li></ul> <h2 id="_2-进程管理"><a href="#_2-进程管理" class="header-anchor">#</a> 2 进程管理</h2> <h3 id="_2-1-进程的基本概念"><a href="#_2-1-进程的基本概念" class="header-anchor">#</a> 2.1 进程的基本概念</h3> <h4 id="_2-1-1-程序的顺序执行及其特征"><a href="#_2-1-1-程序的顺序执行及其特征" class="header-anchor">#</a> 2.1.1 程序的顺序执行及其特征</h4> <ul><li><p>程序的顺序执行是指程序可以保证其按照其顺序执行</p></li> <li><p>特征</p> <ul><li>顺序性</li> <li>封闭性</li> <li>可再现性</li></ul></li></ul> <h4 id="_2-1-2-程序的并发执行及其特征"><a href="#_2-1-2-程序的并发执行及其特征" class="header-anchor">#</a> 2.1.2 程序的并发执行及其特征</h4> <ul><li><p>多道程序并发执行</p></li> <li><p>特征</p> <ul><li>间断性</li> <li>失去封闭性</li> <li>不可再现性 （资源共享，可能使用时被其他程序所修改）</li></ul></li></ul> <h4 id="_2-1-3-进程的特征与状态"><a href="#_2-1-3-进程的特征与状态" class="header-anchor">#</a> 2.1.3 进程的特征与状态</h4> <p><img src="/assets/img/OS04.c5770d5a.png" alt="OS04"></p> <ul><li><p>定义</p> <ul><li>进程是程序的一次执行</li> <li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动</li> <li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位</li></ul></li> <li><p>特征</p> <ul><li>结构性</li> <li>动态性</li> <li>并发性</li> <li>独立性</li> <li>异步性</li></ul></li> <li><p>状态</p> <ul><li>活动进程的三种状态
<ul><li>就绪</li> <li>执行</li> <li>阻塞</li></ul></li> <li>另外两种状态
<ul><li>创建</li> <li>终止</li></ul></li> <li>挂起状态（将进程内存 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 外存）</li></ul> <p><img src="/assets/img/OS03.0304025c.png" alt="OS03"></p> <blockquote><p>N 核 CPU ，共有 M 个进程</p> <ul><li>就绪态用户进程最多几个？最少几个？</li> <li>M-N, 0</li> <li>执行态用户进程最多几个？最少几个？</li> <li>N, 0</li> <li>阻塞态用户进程最多几个？最少几个？</li> <li>M, 0</li></ul></blockquote></li></ul> <h4 id="_2-1-4-进程控制块-pcb"><a href="#_2-1-4-进程控制块-pcb" class="header-anchor">#</a> 2.1.4 进程控制块 PCB</h4> <p>系统是根据进程的 PCB 感知到该进程的存在的,PCB 是进程存在的<strong>唯一标志</strong>，因此系统总是通过 PCB 对进程进行控制的</p> <ul><li><p>PCB 中的信息</p> <ul><li>进程标识信息
<ul><li>内部标识号 PID ，操作系统分配</li> <li>外部标识号 由字母数字组成的，创建者提供</li></ul></li> <li>处理机状态信息
<ul><li>通用寄存器</li> <li>指令计数器</li> <li>程序状态字 PSW</li> <li>用户栈指针</li></ul></li> <li>进程调度信息
<ul><li>进程状态</li> <li>进程优先级</li> <li>进程调度所需的其它信息</li> <li>事件</li></ul></li> <li>进程控制信息
<ul><li>程序和数据的地址</li> <li>进程同步和通信机制</li> <li>资源清单</li> <li>链接指针（当然，索引方式应该是没有的）</li></ul></li></ul></li> <li><p>PCB 组织方式</p> <ul><li><p>链接方式 组织成链表</p> <p><img src="/assets/img/OS05.20cf64d0.png" alt="OS05"></p></li> <li><p>索引方式 额外建立一个索引表，更快，但是额外消耗一部分内存</p> <p><img src="/assets/img/OS06.5d2404f6.png" alt="OS06"></p></li></ul></li></ul> <h3 id="_2-2-进程控制"><a href="#_2-2-进程控制" class="header-anchor">#</a> 2.2 进程控制</h3> <p>通过<strong>原语</strong>来实现</p> <p>原语是原子操作，是不可分割的基本单位，要么全做、要么全不做</p> <h4 id="_2-2-1-进程的创建"><a href="#_2-2-1-进程的创建" class="header-anchor">#</a> 2.2.1 进程的创建</h4> <ul><li><p>进程图</p> <p>是一种树状的家族关系，子进程继承父进程资源，如 UNIX</p> <blockquote><p>Windows 不是这种关系，Win 的各个进程之间是平等的，并不是层次关系，进程之间的关系是通过获取句柄来调节的</p></blockquote></li> <li><p>引起创建进程的事件</p> <ul><li>用户登录</li> <li>作业调度</li> <li>提供服务</li> <li>应用请求</li></ul></li> <li><p>进程的创建原语（Create）</p> <ul><li>申请空白 PCB</li> <li>为新进程分配资源</li> <li>初始化 PCB</li> <li>将新进程插入就绪队列</li></ul></li></ul> <h4 id="_2-2-2-进程的终止"><a href="#_2-2-2-进程的终止" class="header-anchor">#</a> 2.2.2 进程的终止</h4> <ul><li><p>引起进程终止的事件</p> <ul><li>正常结束</li> <li>异常结束
<ul><li>越界错</li> <li>保护错</li> <li>非法指令</li> <li>特权指令错</li> <li>运行超时</li> <li>等待超时</li> <li>算术运算错</li> <li>I/O 故障</li></ul></li> <li>外界干预
<ul><li>操作员或操作系统干预</li> <li>父进程请求</li> <li>父进程中止</li></ul></li></ul></li> <li><p>进程的终止原语（termination）</p> <ul><li>根据被终止进程的标识符，检索出 PCB ，读取进程状态</li> <li>若处于执行状态，则立即终止</li> <li>若还有子孙进程，则递归终止</li> <li>将资源归还其父进程或者系统</li> <li>将被终止进程 PCB 从所在队列中移出</li></ul></li></ul> <h4 id="_2-2-3-进程的阻塞与唤醒"><a href="#_2-2-3-进程的阻塞与唤醒" class="header-anchor">#</a> 2.2.3 进程的阻塞与唤醒</h4> <ul><li><p>引起进程阻塞和唤醒的事件</p> <ul><li>请求系统服务</li> <li>启动某种操作</li> <li>新数据尚未到达</li> <li>无新工作可做</li></ul></li> <li><p>进程阻塞原语（block）</p></li> <li><p>进程唤醒原语（wakeup）</p></li></ul> <h4 id="_2-2-4-进程的挂起和激活"><a href="#_2-2-4-进程的挂起和激活" class="header-anchor">#</a> 2.2.4 进程的挂起和激活</h4> <ul><li>进程挂起原语（suspend）</li> <li>进程激活原语（active）</li></ul> <h3 id="_2-3-进程同步"><a href="#_2-3-进程同步" class="header-anchor">#</a> 2.3 进程同步</h3> <p><a href="https://github.com/SigureMo/notev/tree/master/Codes/OS/process_sync" target="_blank" rel="noopener noreferrer">本章节 Python 实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="_2-3-1-进程同步的基本概念"><a href="#_2-3-1-进程同步的基本概念" class="header-anchor">#</a> 2.3.1 进程同步的基本概念</h4> <ul><li>两种形式的制约关系
<ul><li>间接相互制约关系（互斥） 多个进程共享系统资源</li> <li>直接相互制约关系（同步） 多个进程之间共同访问缓冲区</li></ul></li></ul> <p>问题的根源就在于 临界资源</p> <ul><li><p>临界资源 就是发生冲突的部分 比如共享的系统资源（硬件临界资源）、共享的缓冲区（软件临界资源）</p></li> <li><p>临界区 每个进程中访问临界资源的那段<em>代码</em>，我们将一个访问临界资源的循环进程描述如下</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>while (TRUE) {
   进入区（entry section）
   临界区（critical section）
   退出区（exit section）
   剩余区（remainder section）
}
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>各进程对自己的临界区访问是互斥的</p></li> <li><p>同步机制应遵循的规则</p> <ul><li>空闲让进</li> <li>忙则等待</li> <li>有限等待</li> <li>让权等待</li></ul></li></ul> <h4 id="_2-3-2-硬件同步机制"><a href="#_2-3-2-硬件同步机制" class="header-anchor">#</a> 2.3.2 硬件同步机制</h4> <ul><li>关中断 但是会引发一系列问题</li> <li>利用 Test-and-Set 指令实现互斥 将“测试并建立”作为一条原语</li> <li>利用 Swap 指令实现进程互斥 使用 lock 和 key 两个变量</li></ul> <p>他们虽然都实现了互斥，但是都有一个很大的问题，就是尝试访问资源是连续测试的（如 <code>while TS(&amp;lock);</code>），仍然浪费 CPU 资源，不符合“让权等待”原则</p> <h4 id="_2-3-3-信号量机制"><a href="#_2-3-3-信号量机制" class="header-anchor">#</a> 2.3.3 信号量机制</h4> <ul><li><p>整型信号量</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>S <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    S<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    S<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>问题当然是，还是不符合“让权等待”原则</p></li> <li><p>记录型信号量</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">process_control_block</span> <span class="token operator">*</span>list<span class="token punctuation">;</span>
<span class="token punctuation">}</span> semaphore<span class="token punctuation">;</span>
<span class="token function">wait</span> <span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    S<span class="token operator">-&gt;</span>value<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">signal</span><span class="token punctuation">(</span>semaphore <span class="token operator">*</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   S<span class="token operator">-&gt;</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">wakeup</span><span class="token punctuation">(</span>S<span class="token operator">-&gt;</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>与前面不同的是，我们现在定义了一个数据结构，增加了一个列表，这个列表干嘛呢？</p> <p>由于我们要在无法获取资源的时候将 CPU 资源让出去，所以 while 轮询是不可行的了，我们可以使用 block 原语将自己阻塞起来，等到有资源的时候让别人唤醒自己，当然，为了保证别人能唤醒自己，就要把自己存储到一个列表中，就是我们新的数据结构中的那个列表啦</p> <p>另外，我们可以将 value 当做资源数，初始化的数量就是资源的总数量</p></li> <li><p>AND 型信号量</p> <p>当一个进程需要多个资源才能执行怎么办呢？比如进程一二都需要资源一二，进程一请求资源一成功，进程二请求资源二成功，这时候进程一继续请求资源二，把自己阻塞起来了，进程二请求资源一，也把自己阻塞起来了，结果……死锁了……</p> <p>如何解决？如果我们将某个进程请求一系列资源作为一个原语就可以啦，这样就不需要担心请求一部分另一部分没请求到的问题啦，这时候使用 <code>Swait(S1, S2, ..., Sn)</code> 和 <code>Ssignal(S1, S2, S3, ..., Sn)</code> ， <code>S1</code> 到 <code>Sn</code> 表示该进程所需要的所有资源</p></li> <li><p>信号量集</p> <p>在 AND 型信号量的基础上增加 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">t_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示资源的分配下限值，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mi>i</mi></msub><mo>≥</mo><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S_i \geq t_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 才予以分配，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 表示资源的需求量，对应格式变为 - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>w</mi><mi>a</mi><mi>i</mi><mi>t</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>t</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext></mtext><mo separator="true">,</mo><msub><mi>S</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>t</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Swait(S_1, t_1, d_1, \cdots, S_n, t_n, d_n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> - <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mi>s</mi><mi>i</mi><mi>g</mi><mi>n</mi><mi>a</mi><mi>l</mi><mo stretchy="false">(</mo><msub><mi>S</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>d</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>⋯</mo><mtext></mtext><mo separator="true">,</mo><msub><mi>S</mi><mi>n</mi></msub><mo separator="true">,</mo><msub><mi>d</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Ssignal(S_1,d_1, \cdots, S_n, d_n)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p> <p>有以下几个特殊用法：</p> <ul><li><code>Swait(S, d, d)</code> 每次申请 d 个资源，低于 d 个不予申请</li> <li><code>Swait(S, 1, 1)</code> 一般的记录型信号量</li> <li><code>Swait(S, 1, 0)</code> <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">S \geq 1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 时，允许多个进程进入特定区， <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">S = 0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 时，将阻止任何进程进入特定区</li></ul> <blockquote><p>有个细节需要注意下，就是 <code>Swait</code> 结束后被唤醒并不能直接进入临界区，还需要重新尝试请求资源，因为这个时候并不能保证所有资源都就绪，而 <code>wait</code> 只需要一个资源，这就保证了被唤醒后资源一定全部就绪，所以可以直接进入临界区</p></blockquote></li></ul> <h4 id="_2-3-4-信号量的应用"><a href="#_2-3-4-信号量的应用" class="header-anchor">#</a> 2.3.4 信号量的应用</h4> <ul><li><p>使用信号量实现互斥</p> <p>（两个进程为例）使用 mutex 作为互斥信号量，它可以取 <code>{-1, 0, 1}</code> ，初始化为 1</p> <blockquote><ul><li>mutex = 1，表示两个进程均未进入临界区</li> <li>mutex = 0，表示一个进程进入临界区</li> <li>mutex = -1，表示一个进程进入临界区，另一个尝试进入临界区失败，阻塞并存入队列</li></ul></blockquote> <p>为了实现互斥，就需要两个进程进入临界区前调用 <code>wait(mutex)</code> ，出临界区后调用 <code>signal(mutex)</code>，否则会引发错误</p></li> <li><p>利用信号量实现前趋关系</p> <p>如何保证一个进程运行到命令 B 的时候另一个进程已经将命令 A 运行完了？比如一个进程要读取另一个进程写完的文件，怎么保证在这之前另一进程写操作已经完成？</p> <p>仍然使用这个套路，不过将 mutex 初值置为 0 ，我们在后继任务<em>前</em>调用 <code>wait(mutex)</code> ，在前趋任务完成<em>后</em>调用 <code>signal(mutex)</code> ，这样就可以保证后继任务先到达的话会阻塞，而前趋任务完成后，就会“通知”后继任务可以开始做啦</p></li> <li><p>管程机制</p> <p>是使用面向对象将共享变量、条件变量以及各种方法等等封装起来，同时只能有一个进程进入管程，这就保证了对临界资源的访问是互斥的</p> <p>当调用管程的进程被阻塞时，其它进程也就不能进入管程使用资源，为了解决该问题，管程内设了条件变量，当进程因为条件 x 而发生阻塞时，进程调用 <code>x.wait</code> 方法，将自己加入阻塞队列，直到条件 x 发生了变化，其它进程（当时正在管程内的进程）调用 <code>x.signal</code> 将队列 x 下的进程唤醒</p></li></ul> <h3 id="_2-4-经典进程的同步问题"><a href="#_2-4-经典进程的同步问题" class="header-anchor">#</a> 2.4 经典进程的同步问题</h3> <h4 id="_2-4-1-生产者-消费者问题"><a href="#_2-4-1-生产者-消费者问题" class="header-anchor">#</a> 2.4.1 生产者-消费者问题</h4> <p><a href="https://github.com/SigureMo/notev/blob/master/Codes/OS/process_sync/PC.py" target="_blank" rel="noopener noreferrer">PC.py<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li><p>使用记录型信号量解决该问题</p> <ul><li>生产者先后使用 <code>wait(empty)</code> <code>wait(mutex)</code> <code>signal(mutex)</code> <code>signal(full)</code></li> <li>消费者先后使用 <code>wait(full)</code> <code>wait(mutex)</code> <code>signal(mutex)</code> <code>signal(empty)</code></li></ul> <blockquote><p>注意 <code>wait</code> 的先后顺序，如果 <code>wait(mutex)</code> <code>wait(empty)</code> 可以想象下满了或者空的情况，会出现死锁……</p></blockquote></li> <li><p>利用 AND 信号量解决该问题</p> <ul><li>生产者先后使用 <code>Swait(empty, mutex)</code> <code>Ssignal(mutex, full)</code></li> <li>消费者先后使用 <code>Swait(full, mutex)</code> <code>Ssignal(mutex, empty)</code></li></ul> <p>解决死锁问题</p></li> <li><p>利用管程解决该问题</p> <p>定义好管程内要做的，生产者用 <code>PC.put(x)</code>， 消费者用 <code>PC.get(x)</code> 即可</p></li></ul> <blockquote><p>一些变体</p> <ul><li>缓冲区无限大，那么我们就不需要 <code>wait(empty)</code> <code>signal(empty)</code> 了</li> <li>生产者生产者互斥、消费者消费者互斥，但生产者消费者不互斥，我们只需要设两个互斥信号量即可</li></ul></blockquote> <h4 id="_2-4-2-哲学家进餐问题"><a href="#_2-4-2-哲学家进餐问题" class="header-anchor">#</a> 2.4.2 哲学家进餐问题</h4> <p><a href="https://github.com/SigureMo/notev/blob/master/Codes/OS/process_sync/The_Dining_Philosophers.py" target="_blank" rel="noopener noreferrer">The_Dining_Philosophers.py<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li><p>利用记录型信号量解决该问题</p> <p>防止他们同时拿起左侧筷子造成的死锁，需要有一定的改进方案</p></li> <li><p>利用 AND 信号量机制解决该问题</p> <p>很容易想到这个方法解决上述问题</p></li></ul> <h4 id="_2-4-3-读者-写者问题"><a href="#_2-4-3-读者-写者问题" class="header-anchor">#</a> 2.4.3 读者-写者问题</h4> <p><a href="https://github.com/SigureMo/notev/blob/master/Codes/OS/process_sync/Writer_and_Reader.py" target="_blank" rel="noopener noreferrer">Writer_and_Reader.py<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>需要注意的是，当一个 Writer 进程在写的时候，不允许任何 Reader 进程和 Writer 进程访问该对象</p> <p>但是要怎么实现呢？</p> <ul><li>写者的话，直接用一个互斥信号量 <code>wmutex</code> 就好了</li> <li>读者需要考虑的比较多
<ul><li>首先，读者之间是不互斥的，我们是要解决读者使写者不能读的问题，所以当读者在读的时候， <code>wait(wmutex)</code></li> <li>但是，如果直接 <code>wait(wmutex)</code> 的话，所有“者”都互斥了，可是多个读者是可以同时读的</li> <li>我们判断下是否已经有人在读了，当无人在读的情况下也就是第一个读者才 <code>wait(wmutex)</code>，相应地，最后一个读者才 <code>signal(wmutex)</code></li> <li>为了判断读者数量，额外引进了一个变量，这个变量会成为临界资源，所以需要使用 <code>rmutex</code> 包裹，以保证读者读写该变量时互斥</li></ul></li></ul> <p>另外，可以利用信号量集以更巧妙的方法实现（注意 <code>Swait(S, 1, 0)</code>，只检查资源，不消耗）</p> <p><a href="https://github.com/SigureMo/notev/blob/master/Codes/OS/process_sync/Writer_and_Reader_SemSet.py" target="_blank" rel="noopener noreferrer">Writer_and_Reader.py<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="_2-4-4-其他问题（习题）"><a href="#_2-4-4-其他问题（习题）" class="header-anchor">#</a> 2.4.4 其他问题（习题）</h4> <ul><li><a href="https://github.com/SigureMo/notev/blob/master/Codes/OS/process_sync/Shopping.py" target="_blank" rel="noopener noreferrer">购物问题 Shopping.py<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/SigureMo/notev/blob/master/Codes/OS/process_sync/Processes.py" target="_blank" rel="noopener noreferrer">进程同步 Processes.py<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://github.com/SigureMo/notev/blob/master/Codes/OS/process_sync/Single-plank_Bridge.py" target="_blank" rel="noopener noreferrer">独木桥问题 Single-plank_Bridge.py<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h3 id="_2-5-进程通信"><a href="#_2-5-进程通信" class="header-anchor">#</a> 2.5 进程通信</h3> <ul><li><p>共享存储器系统</p> <ul><li>基于共享数据结构的通信方式</li> <li>基于共享存储区的通信方式 中等信息传递，用户解决同步问题</li></ul></li> <li><p>管道(pipe)通信系统 大量信息传递，系统解决同步问题</p></li> <li><p>消息传递系统 少量信息传递，系统解决同步问题</p></li> <li><p>客户机-服务器系统</p> <ul><li>socket</li> <li>RPC</li></ul></li></ul> <h3 id="_2-6-线程的基本概念"><a href="#_2-6-线程的基本概念" class="header-anchor">#</a> 2.6 线程的基本概念</h3> <h4 id="_2-6-1-线程与进程的对比"><a href="#_2-6-1-线程与进程的对比" class="header-anchor">#</a> 2.6.1 线程与进程的对比</h4> <ul><li>调度的基本单位 切换开销小</li> <li>并发性 线程之间也可以并发执行</li> <li>拥有资源 并不拥有系统额外分配的资源，享有父进程的资源，故创建开销小</li> <li>独立性 同一进程的不同线程之间可以共享资源，独立性不明显</li> <li>系统开销 创建与切换都远比进程快</li> <li>支持多处理机系统 一个进程的多个线程可在多个核心上运行，这使得多个线程之间实现了真的并行，大大提高了该进程的完成速度</li></ul> <h4 id="_2-6-2-线程的状态和线程控制块"><a href="#_2-6-2-线程的状态和线程控制块" class="header-anchor">#</a> 2.6.2 线程的状态和线程控制块</h4> <ul><li>线程的三个状态 和进程一样 <strong>执行</strong>、<strong>就绪</strong>、<strong>阻塞</strong></li> <li>线程控制块 TCB 类似于 PCB</li></ul> <h3 id="_2-7-线程的实现"><a href="#_2-7-线程的实现" class="header-anchor">#</a> 2.7 线程的实现</h3> <h4 id="_2-7-1-线程的实现方式"><a href="#_2-7-1-线程的实现方式" class="header-anchor">#</a> 2.7.1 线程的实现方式</h4> <ul><li><p>内核支持线程 KST</p> <p>内核所“承认”的线程，可获得内核分配的 CPU 时间片，也可在多核 CPU 上实现并行</p> <ul><li>优点
<ul><li>更轻量的结构</li> <li>进程中一个线程阻塞后，其余线程可正常运行</li> <li>多核心可并发执行</li></ul></li></ul></li> <li><p>用户级线程 ULT</p> <p>使用函数库就可以实现，内核并不知道用户级线程的存在，所以内核给它分配的时间片是按其父进程分配的，各个线程将争夺进程的时间片执行</p> <ul><li>优点
<ul><li>线程切换不需要到内核空间（不需要用户态与核心态的切换）</li> <li>调度算法可以是进程专用的</li> <li>用户级线程的实现与 OS 平台无关</li></ul></li></ul></li> <li><p>组合方式</p> <p>用户级线程与内核支持线程的组合（多对一、一对一、多对多）</p></li></ul> <p><img src="/assets/img/OS07.7d09c70b.png" alt="OS07"></p> <h2 id="_3-处理机调度与死锁"><a href="#_3-处理机调度与死锁" class="header-anchor">#</a> 3 处理机调度与死锁</h2> <h3 id="_3-1-处理机调度的层次"><a href="#_3-1-处理机调度的层次" class="header-anchor">#</a> 3.1 处理机调度的层次</h3> <table><thead><tr><th>调度程序</th> <th>调度对象</th> <th>分配资源</th> <th>调度频率</th> <th>适宜的调度算法</th></tr></thead> <tbody><tr><td>长程调度（作业）</td> <td>后备作业</td> <td>内存、设备</td> <td>低</td> <td>资源搭配、先进先出、优先数、短作业优先、最高响应比优先</td></tr> <tr><td>中程调度（交换）</td> <td>就绪进程、等待进程</td> <td>内存、外存</td> <td>中</td> <td>优先算法、FIFO</td></tr> <tr><td>短程调度（进程）</td> <td>就绪进程、就绪线程</td> <td>CPU</td> <td>高</td> <td>轮转法、多级反馈</td></tr></tbody></table> <h4 id="_3-1-1-高级调度"><a href="#_3-1-1-高级调度" class="header-anchor">#</a> 3.1.1 高级调度</h4> <ul><li><p>作业 = JCB + 作业说明书 + 程序 + 数据</p></li> <li><p>作业步 作业的各个相对独立步骤</p></li> <li><p>作业控制块 JCB</p></li> <li><p>调度算法</p> <ul><li>先来先服务算法</li> <li>短作业优先调度算法</li> <li>响应比高者优先的调度算法 综合考虑上面两种算法</li> <li>基于作业优先级的调度算法</li></ul></li></ul> <h4 id="_3-1-2-低级调度"><a href="#_3-1-2-低级调度" class="header-anchor">#</a> 3.1.2 低级调度</h4> <ul><li><p>基本机制</p> <ul><li>排队器</li> <li>分派器</li> <li>上下文切换机制 （两对上下文切换操作）</li></ul></li> <li><p>进程调度方式</p> <ul><li>非抢占方式</li> <li>抢占方式（按一定原则抢占 CPU）
<ul><li>优先权原则</li> <li>短作业（进程）优先原则</li> <li>时间片原则</li></ul></li></ul></li></ul> <h4 id="_3-1-3-中级调度"><a href="#_3-1-3-中级调度" class="header-anchor">#</a> 3.1.3 中级调度</h4> <p>将内存上的进程转换到外存上或相反的过程，也就是进程的挂起与唤醒，提高了内存的利用率</p> <h3 id="_3-2-调度队列模型和调度准则"><a href="#_3-2-调度队列模型和调度准则" class="header-anchor">#</a> 3.2 调度队列模型和调度准则</h3> <h4 id="_3-2-1-调度队列模型"><a href="#_3-2-1-调度队列模型" class="header-anchor">#</a> 3.2.1 调度队列模型</h4> <ul><li><p>仅有进程调度的调度队列模型</p></li> <li><p>具有高级和低级调度的调度队列模型</p></li> <li><p>同时具有三级调度的调度队列模型</p> <p><img src="/assets/img/OS08.9887a1fe.png" alt="OS08"></p></li></ul> <h4 id="_3-2-2-选择调度方式和调度算法的若干原则"><a href="#_3-2-2-选择调度方式和调度算法的若干原则" class="header-anchor">#</a> 3.2.2 选择调度方式和调度算法的若干原则</h4> <ul><li><p>面向用户的原则</p> <ul><li>周转时间快 （使用平均周转时间评估）</li> <li>响应时间快</li> <li>截止时间的保证</li> <li>优先权准则</li></ul></li> <li><p>面向系统的准则</p> <ul><li>系统吞吐量高</li> <li>处理机利用率好</li> <li>各类资源的平衡利用</li></ul></li></ul> <h3 id="_3-3-调度算法"><a href="#_3-3-调度算法" class="header-anchor">#</a> 3.3 调度算法</h3> <ul><li>周转时间：作业等待的时间</li> <li>带权周转时间：周转时间 / 服务时间</li></ul> <h4 id="_3-3-1-先来先服务算法"><a href="#_3-3-1-先来先服务算法" class="header-anchor">#</a> 3.3.1 先来先服务算法</h4> <p>很明显， FCFS 的周转时间会很长</p> <h4 id="_3-3-2-短作业（进程）优先调度算法"><a href="#_3-3-2-短作业（进程）优先调度算法" class="header-anchor">#</a> 3.3.2 短作业（进程）优先调度算法</h4> <p>SJF 算法极大地提高了系统吞吐量，但是会出现长作业长期不被调度的情况</p> <h4 id="_3-3-3-高优先权优先调度算法"><a href="#_3-3-3-高优先权优先调度算法" class="header-anchor">#</a> 3.3.3 高优先权优先调度算法</h4> <ul><li><p>优先权调度算法的类型</p> <ul><li>非抢占式优先权算法</li> <li>抢占式优先权调度算法</li></ul></li> <li><p>优先权的类型</p> <ul><li>静态优先权 不可改变的</li> <li>动态优先权 可随着进程的等待时间而改变，我们可以规定，在就绪队列的进程，随其等待时间的增长，其优先权以速率 a 提高</li></ul></li> <li><p>高响应比优先调度算法</p> <p>优先权 = (等待时间 + 要求服务时间) / 要求服务时间</p></li></ul> <h4 id="_3-3-4-基于时间片的轮转调度算法"><a href="#_3-3-4-基于时间片的轮转调度算法" class="header-anchor">#</a> 3.3.4 基于时间片的轮转调度算法</h4> <ul><li><p>时间片大小的确定</p> <ul><li>时间片太大会使得算法退化，时间片太小会增大切换上下文的开销，故可以取略大于一次典型交互所需要的时间作为时间片</li></ul></li></ul> <h4 id="_3-3-5-多队列调度算法"><a href="#_3-3-5-多队列调度算法" class="header-anchor">#</a> 3.3.5 多队列调度算法</h4> <p>分成不同的队列，为不同就绪队列设置不同的调度算法</p> <p><img src="/assets/img/OS09.7eb4aa30.png" alt="OS09"></p> <h4 id="_3-3-6-多级反馈队列调度算法"><a href="#_3-3-6-多级反馈队列调度算法" class="header-anchor">#</a> 3.3.6 多级反馈队列调度算法</h4> <ul><li>设置多个就绪队列</li> <li>为每个队列设置一个优先级</li> <li>仅当优先级高的队列空闲时才能调度优先级低的队列</li></ul> <h3 id="_3-4-实时调度"><a href="#_3-4-实时调度" class="header-anchor">#</a> 3.4 实时调度</h3> <h4 id="_3-4-1-实现实时调度的基本条件"><a href="#_3-4-1-实现实时调度的基本条件" class="header-anchor">#</a> 3.4.1 实现实时调度的基本条件</h4> <ul><li>提供必要的信息 就绪时间等等</li> <li>系统处理能力强</li> <li>采用抢占式调度机制</li> <li>具有快速切换机制</li></ul> <h4 id="_3-4-2-实时调度算法的分类"><a href="#_3-4-2-实时调度算法的分类" class="header-anchor">#</a> 3.4.2 实时调度算法的分类</h4> <ul><li>非抢占式调度算法
<ul><li>非抢占式轮转调度算法</li> <li>非抢占式优先调度算法 将实时任务放在队首</li></ul></li> <li>抢占式调度算法
<ul><li>基于时钟中断的抢占式优先权调度算法 时钟周期的整数倍时刻才能抢占</li> <li>立即抢占的优先权调度算法</li></ul></li></ul> <h3 id="_3-5-产生死锁的原因和必要条件"><a href="#_3-5-产生死锁的原因和必要条件" class="header-anchor">#</a> 3.5 产生死锁的原因和必要条件</h3> <h4 id="_3-5-1-产生死锁的原因"><a href="#_3-5-1-产生死锁的原因" class="header-anchor">#</a> 3.5.1 产生死锁的原因</h4> <ul><li><p>竞争资源（竞争非剥夺性资源） 资源数量不足需求 形成<strong>环路</strong></p> <p><img src="data:image/png;base64,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" alt="OS10"></p></li> <li><p>进程间推进顺序非法</p></li></ul> <h4 id="_3-5-2-产生死锁的必要条件"><a href="#_3-5-2-产生死锁的必要条件" class="header-anchor">#</a> 3.5.2 产生死锁的必要条件</h4> <ul><li>互斥条件</li> <li>请求和保持条件 所需资源使用完之前不释放已有资源</li> <li>不剥夺条件 只能主动释放资源，其他人不可抢占</li> <li>环路等待条件 发生死锁时，必然存在资源的环路链</li></ul> <h4 id="_3-5-3-处理死锁的基本方法"><a href="#_3-5-3-处理死锁的基本方法" class="header-anchor">#</a> 3.5.3 处理死锁的基本方法</h4> <ul><li>预防死锁</li> <li>避免死锁</li> <li>检测死锁</li> <li>解除死锁</li></ul> <h3 id="_3-6-预防死锁"><a href="#_3-6-预防死锁" class="header-anchor">#</a> 3.6 预防死锁</h3> <p>由于死锁时必要条件一定满足，所以破坏了死锁的必要条件就可以防止死锁，当然，互斥条件我们不应该破坏，因为我们需要它来保证进程的同步问题</p> <h4 id="_3-6-1-摒弃-请求和保持-条件"><a href="#_3-6-1-摒弃-请求和保持-条件" class="header-anchor">#</a> 3.6.1 摒弃“请求和保持”条件</h4> <p>由动态分配改为静态分配，在所有进程运行之前一次性将所有所需资源申请下来</p> <p>但是，这大大降低了资源的利用率</p> <h4 id="_3-6-2-摒弃-不剥夺-条件"><a href="#_3-6-2-摒弃-不剥夺-条件" class="header-anchor">#</a> 3.6.2 摒弃“不剥夺”条件</h4> <p>新的资源请求会剥夺已占有的资源</p> <p>很复杂很复杂，打印机写一半怎么处理呢？增加了系统开销</p> <h4 id="_3-6-3-摒弃-环路等待-条件"><a href="#_3-6-3-摒弃-环路等待-条件" class="header-anchor">#</a> 3.6.3 摒弃“环路等待”条件</h4> <p>资源有序分配，将各个资源标号，每次申请资源都要按序号递增的次序来申请，避免了环路的产生</p> <blockquote><p>比如一个进程已经拥有了一个序号比较高的资源，此时想申请序号比较低的资源的话，必须先释放序号比较高的资源</p></blockquote> <p>相比前两种是比较好的策略，但仍有一些不足，比如序号的分配等等问题</p> <h3 id="_3-7-避免死锁"><a href="#_3-7-避免死锁" class="header-anchor">#</a> 3.7 避免死锁</h3> <h4 id="_3-7-1-系统安全状态"><a href="#_3-7-1-系统安全状态" class="header-anchor">#</a> 3.7.1 系统安全状态</h4> <p>如果为进程分配资源后系统会进入不安全状态，那么就不给它分配资源</p> <p>所谓<strong>安全状态</strong>，就是指系统<strong>存在</strong>某种进程顺序来为每个进程分配其所需资源，使得所有进程都能顺利完成，否则即为不安全状态</p> <blockquote><p>当然，不安全状态只是不安全，可能发生死锁，并不是一定发生死锁，而安全状态保证了不会发生死锁</p></blockquote> <ul><li><p>Example</p> <table><thead><tr><th>进程号</th> <th>总共需求</th> <th>已分配</th> <th>还需</th> <th>剩余</th></tr></thead> <tbody><tr><td>P1</td> <td>10</td> <td>5</td> <td>5</td> <td>3</td></tr> <tr><td>P2</td> <td>4</td> <td>2</td> <td>2</td> <td></td></tr> <tr><td>P3</td> <td>9</td> <td>2</td> <td>7</td> <td></td></tr></tbody></table> <p>很明显，存在安全序列 &lt;P2, P1, P3&gt; 使得进程全部执行完毕</p> <p>那么，P3 申请一个资源的话，我们要不要给呢？</p> <p>首先，<strong>假如</strong>分配的话，会变成如下状态</p> <table><thead><tr><th>进程号</th> <th>总共需求</th> <th>已分配</th> <th>还需</th> <th>剩余</th></tr></thead> <tbody><tr><td>P1</td> <td>10</td> <td>5</td> <td>5</td> <td>2</td></tr> <tr><td>P2</td> <td>4</td> <td>2</td> <td>2</td> <td></td></tr> <tr><td>P3</td> <td>9</td> <td>3</td> <td>6</td> <td></td></tr></tbody></table> <p>嗯，找不出来那样的一个序列了，也就是系统会进入不安全状态，所以，拒绝！不给分配！</p></li></ul> <h4 id="_3-7-2-利用银行家算法避免死锁"><a href="#_3-7-2-利用银行家算法避免死锁" class="header-anchor">#</a> 3.7.2 利用银行家算法避免死锁</h4> <p>（万能的 Dijkstra）</p> <ul><li><p>银行家算法中的数据结构</p> <p>n 为进程数， m 为资源数</p> <ul><li>可利用资源向量 Available (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>)</li> <li>最大需求矩阵 Max (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>)</li> <li>分配矩阵 Allocation (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>)</li> <li>需求矩阵 Need (<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">n \times m</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>)</li></ul></li></ul> <blockquote><p>具体算法的话，就是上面例子里的一个资源换成多个资源就好啦</p></blockquote> <h3 id="_3-8-死锁的检测与解除"><a href="#_3-8-死锁的检测与解除" class="header-anchor">#</a> 3.8 死锁的检测与解除</h3> <h4 id="_3-8-1-死锁的检测"><a href="#_3-8-1-死锁的检测" class="header-anchor">#</a> 3.8.1 死锁的检测</h4> <p>由于死锁的预防的资源利用率太低，而死锁的避免又消耗了大量的计算资源来实现，所以在死锁发生的并不频繁的情况下，可以使用死锁的检测 + 解除，当然，我们可以选择在 CPU 利用率比较低的时候才检测，以降低对 CPU 的使用</p> <ul><li>资源分配图</li></ul> <p>与前面的环路图是一样的，只不过这里资源结点可以代表多个资源，进程指向资源仍旧代表进程请求资源，资源指向进程仍旧代表资源以分配给该进程，只不过每条线代表一个资源</p> <p><img src="/assets/img/OS11.dec55523.png" alt="OS11"></p> <p>我们可以尝试通过对资源分配图进行简化来判断是否发生死锁，非死锁情况下资源分配图可简化为各个独立的结点</p> <h4 id="_3-8-2-死锁的解除"><a href="#_3-8-2-死锁的解除" class="header-anchor">#</a> 3.8.2 死锁的解除</h4> <ul><li>剥夺资源 从其他进程剥夺足够数量的资源给死锁进程</li> <li>撤销进程 kill 掉死锁进程</li></ul> <blockquote><p><a href="https://github.com/SigureMo/notev/tree/master/Codes/OS/process_scheduling_and_deadlocks" target="_blank" rel="noopener noreferrer">作业<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="_4-存储器管理"><a href="#_4-存储器管理" class="header-anchor">#</a> 4 存储器管理</h2> <h3 id="_4-1-存储器的层次结构"><a href="#_4-1-存储器的层次结构" class="header-anchor">#</a> 4.1 存储器的层次结构</h3> <h4 id="_4-1-1-多级存储器结构"><a href="#_4-1-1-多级存储器结构" class="header-anchor">#</a> 4.1.1 多级存储器结构</h4> <p><img src="/assets/img/OS12.4fdd3d5f.png" alt="OS12"></p> <h4 id="_4-1-1-主存储器与寄存器"><a href="#_4-1-1-主存储器与寄存器" class="header-anchor">#</a> 4.1.1 主存储器与寄存器</h4> <p>嗯……就是主存储器和寄存器……</p> <h4 id="_4-1-2-高速缓存和磁盘缓存"><a href="#_4-1-2-高速缓存和磁盘缓存" class="header-anchor">#</a> 4.1.2 高速缓存和磁盘缓存</h4> <ul><li><p>高速缓存 Cache</p> <p>解决 Memory 与 CPU 速度不匹配的问题</p></li> <li><p>磁盘缓存</p> <p>解决磁盘 I/O 与 Memory 速度不匹配的问题，使用 Memory 部分空间作为磁盘的缓存区，用于暂存频繁使用的磁盘数据</p></li></ul> <h4 id="_4-1-3-内存管理"><a href="#_4-1-3-内存管理" class="header-anchor">#</a> 4.1.3 内存管理</h4> <p>（概述，后面详细阐述）</p> <ul><li>内存的分配与回收
<ul><li>直接分配 程序内地址为固定值</li> <li>静态分配 作业装入内存后地址固定不变</li> <li>动态分配 作业装入内存后地址可变</li></ul></li> <li>地址转换
<ul><li>逻辑地址：源程序内的变量等地址经过编译或汇编后生成逻辑地址</li> <li>物理地址：程序由操作系统装入内存后所指的真实内存地址</li></ul></li> <li>内存保护
<ul><li>防止进程的数据被非法访问</li> <li>防止越界
<ul><li>上下界寄存器</li> <li>基址、限长寄存器</li></ul></li></ul></li> <li>内存共享
<ul><li>多个进程共享内存中的同一段信息</li></ul></li> <li>内存扩充
<ul><li>覆盖 让常用功能常驻内存，非常用功能按需装入</li> <li>对换 挂起不用的程序段</li> <li>虚拟存储器 利用程序的局部性原理，将<strong>部分程序装入</strong></li></ul></li></ul> <h3 id="_4-2-程序的装入和链接"><a href="#_4-2-程序的装入和链接" class="header-anchor">#</a> 4.2 程序的装入和链接</h3> <h4 id="_4-2-1-程序的装入"><a href="#_4-2-1-程序的装入" class="header-anchor">#</a> 4.2.1 程序的装入</h4> <blockquote><p>即上面的三种分配方式</p></blockquote> <ul><li>绝对装入方式 直接</li> <li>可重定位装入方式
<ul><li>静态重定位 程序执行之前地址转换完毕</li> <li>动态重定位 程序执行期间进行地址转换</li></ul></li></ul> <h4 id="_4-2-2-程序的链接"><a href="#_4-2-2-程序的链接" class="header-anchor">#</a> 4.2.2 程序的链接</h4> <p><img src="/assets/img/OS13.e7b333a9.png" alt="OS13"></p> <ul><li>静态链接 程序运行前链接</li> <li>装入时动态链接 运行前将所有可能需要运行的模块装入链接
<ul><li>便于修改和更新</li> <li>便于实现对目标模块的共享</li></ul></li> <li>运行时动态链接 运行时按需装入链接（如 <code>dll</code>）</li></ul> <h3 id="_4-3-连续分配方式"><a href="#_4-3-连续分配方式" class="header-anchor">#</a> 4.3 连续分配方式</h3> <h4 id="_4-3-1-单一连续分配"><a href="#_4-3-1-单一连续分配" class="header-anchor">#</a> 4.3.1 单一连续分配</h4> <p><strong>单用户、单任务</strong>，只需要考虑系统区和用户区，用户区也只有一个任务……</p> <h4 id="_4-3-2-固定分区分配"><a href="#_4-3-2-固定分区分配" class="header-anchor">#</a> 4.3.2 固定分区分配</h4> <p><strong>一个分区一道作业</strong>，所以就需要划分分区咯</p> <h4 id="_4-3-3-动态分区分配"><a href="#_4-3-3-动态分区分配" class="header-anchor">#</a> 4.3.3 动态分区分配</h4> <p>根据进程的实际需要，<strong>动态地为之分配内存空间</strong></p> <ul><li><p>数据结构</p> <ul><li>空闲分区表</li> <li>空闲分区链 （就是个链表）</li></ul></li> <li><p>分区分配算法</p> <ul><li>首次适应算法 从头找，能放下该作业就放</li> <li>循环首次适应算法 使用一个指针，这样就不会每次都从头找啦</li> <li>最佳适应算法 每次找满足条件的最小分区
<ul><li>易形成碎片</li></ul></li> <li>最坏适应算法 每次找最大的分区，分割出一部分分配给该作业使用
<ul><li>使得存储器中缺乏大的空闲分区</li> <li>查找效率高</li> <li>产生碎片少</li></ul></li></ul></li></ul> <blockquote><ul><li>内碎片 分区内部未利用的空间</li> <li>外碎片 分区之间未利用的空间</li></ul></blockquote> <ul><li>分区回收算法
<ul><li>看上下有没有空闲区咯，有的话当然要合并~</li></ul></li></ul> <h4 id="_4-3-4-可重定位分区分配"><a href="#_4-3-4-可重定位分区分配" class="header-anchor">#</a> 4.3.4 可重定位分区分配</h4> <p>依赖于 4.1.3 中提到的<em>动态分配</em>技术，这样分区就可以移动啦，然后我们就可以将分区进行拼接、使之紧凑起来</p> <h3 id="_4-4-基本分页存储管理方式"><a href="#_4-4-基本分页存储管理方式" class="header-anchor">#</a> 4.4 基本分页存储管理方式</h3> <p>将内存分为好多好多页，支持不连续分配，使用页表形成地址映射，<strong>每个进程一个页表</strong></p> <ul><li>可实现虚存</li> <li>避免移动</li> <li>避免外部碎片</li></ul> <h4 id="_4-4-1-页面与页表"><a href="#_4-4-1-页面与页表" class="header-anchor">#</a> 4.4.1 页面与页表</h4> <ul><li><strong>页面</strong>就是将<strong>逻辑地址空间</strong>分为大小相等的片，其大小应为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></li> <li><strong>物理块</strong>是<strong>物理地址空间</strong>对应的与页面大小相同的存储块</li> <li><strong>页表</strong>就是将<strong>页（面）号与（物理）块号</strong>对应起来的映射表</li></ul> <p>当然，现在寻址的话需要两部分地址号了，一部分是页号，一部分是页内号（位移量），一般情况下页内大小为 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn><mi>K</mi></mrow><annotation encoding="application/x-tex">4K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> ，故页内号需要使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">12bit</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span> 的地址，如果是 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>32</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">32bit</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">2</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span> 系统的话，那么剩下 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">20bit</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span> 就是页号地址空间啦，即最多 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>M</mi></mrow><annotation encoding="application/x-tex">1M</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span> 个页</p> <h4 id="_4-4-2-地址变换机构"><a href="#_4-4-2-地址变换机构" class="header-anchor">#</a> 4.4.2 地址变换机构</h4> <ul><li><p>基本的地址变换机构</p> <p>那么我们如何将逻辑地址转换成物理地址呢？</p> <p><img src="/assets/img/OS14.e32b7b5a.png" alt="OS14"></p> <p>首先，获取页号和位移量，然后根据页表寄存器中的页面始址与页号获得该页的实际物理地址（开始位置），然后再加上页内的偏移量就得到了要找的物理地址</p> <p>但是，我们的页表已经非常大了，寄存器是肯定放不下了，需要放到内存中去，也就是说，我们每次访存需要先访问内存中的页表，然后据此再得到真正想要访问的地址，也就是访存次数多了一倍，效率大大降低……</p></li> <li><p>具有快表的地址变换机构</p> <p><img src="/assets/img/OS15.421b0d0b.png" alt="OS15"></p> <p>根据局部性原理，我们增加一个快表（联想寄存器），存储最近访问过的页表项，据统计，快表命中率可达 90% 以上，大大降低了页表方式带来的效率降低影响</p></li></ul> <h4 id="_4-4-3-两级和多级页表"><a href="#_4-4-3-两级和多级页表" class="header-anchor">#</a> 4.4.3 两级和多级页表</h4> <p><img src="/assets/img/OS16.fdfab360.png" alt="OS16"></p> <p>我们的页表方式实现了非连续存储，但是我们的页表本身却也是放在内存里的，而且其大小也超过了一页的大小（<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mi>K</mi></mrow><annotation encoding="application/x-tex">1K</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>），这样问题就来了，页表到底是要如何存储呢？</p> <p>回到最初，我们是如何将离散存储的内存页组织起来的？很明显是通过页表，但是现在要求连续存储的页表也要离散存储了，我们如何将其组织起来呢？那就再加一层页表咯，这就形成了两级页表</p> <p>事实上，在 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>64</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">64bit</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span> 系统下，三级页表都是不够的，但是我们事实上也用不上那么大的地址空间（等内存能那么大得多少年后啊……），所以暂时使用三级页表也是能满足现在的需求的</p> <h4 id="_4-4-4-页式管理的分配与回收"><a href="#_4-4-4-页式管理的分配与回收" class="header-anchor">#</a> 4.4.4 页式管理的分配与回收</h4> <p><img src="/assets/img/OS17.2d6db9c7.png" alt="OS17"></p> <p>根据位示图进行分配与回收即可</p> <h4 id="_4-4-5-页式管理的特点"><a href="#_4-4-5-页式管理的特点" class="header-anchor">#</a> 4.4.5 页式管理的特点</h4> <ul><li>优点
<ul><li>分配与回收简单</li> <li>消除外碎片</li> <li>可实现虚存、共享</li></ul></li> <li>缺点
<ul><li>页面划分不考虑程序的逻辑结构</li> <li>共享受限</li> <li>二次访内，速度慢</li></ul></li></ul> <h3 id="_4-5-分段存储管理方式"><a href="#_4-5-分段存储管理方式" class="header-anchor">#</a> 4.5 分段存储管理方式</h3> <p>分页实现了对内存的高效利用，消除了外碎片，但是其对于用户来说仍然只是取某个地址，然后操作系统根据后 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>12</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">12bit</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">2</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span> 作为页内地址，前 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>20</mn><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">20bit</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">0</span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span> 为页号，实际过程对用户并不可见，用户只需要按原来的方式取某个地址就好</p> <p>所以说，分页存储可以说是在底层的一种管理实现方式，大多是与硬件相耦合的，可以做到对内存的更高效利用</p> <p>引入本节的分段存储方式，并不是说分页存储不好，因为它们根本是在两种层级上的问题，后面会介绍它们相互结合的方式——段页式存储——就很好地结合了两者的优点，在底层仍然使用分页式存储，上层逻辑存储使用分段式存储，但是这里，我们底层仍然使用的是连续存储方式哦</p> <p>那么分段有什么优点呢？</p> <h4 id="_4-5-1-分段存储管理方式的引入"><a href="#_4-5-1-分段存储管理方式的引入" class="header-anchor">#</a> 4.5.1 分段存储管理方式的引入</h4> <ul><li>方便编程 我们可以为某一段程序（比如一个函数）分配一段连续的空间，这样就可以很方便地使用段内的偏移量进行编程了</li> <li>信息共享 我们很容易分出一个段来供进程来共享</li> <li>信息保护</li> <li>动态增长</li> <li>动态链接</li></ul> <h4 id="_4-5-2-分段系统的基本原理"><a href="#_4-5-2-分段系统的基本原理" class="header-anchor">#</a> 4.5.2 分段系统的基本原理</h4> <p>既然逻辑空间仍然划分为不等长的几段，这几段也是分别放在不同的位置，所以，我们还是需要一个表建立索引关系，只不过这次我们需要记录的有段号、段长、基址（某段的首地址）三个信息，因为我们现在<strong>每段不等长</strong>了，形成的表格称为段表，也放在内存内</p> <p>相应地，我们现在给出的地址必须由段号和段内偏移两部分组成（真的是二维的寻址方式，而分页仍然使用一维寻址，两个号由操作系统自动计算得出），当然，我们仍然是两次访存，想要快点也是要建立快表</p> <h4 id="_4-5-3-信息共享"><a href="#_4-5-3-信息共享" class="header-anchor">#</a> 4.5.3 信息共享</h4> <p>比如一个多用户操作系统运行一个文本编辑进程，但多个用户每人一个数据区，如果是分页式是如何的呢？</p> <p><img src="/assets/img/OS18.454f03e7.png" alt="OS18"></p> <p>emmm 虽说共用一个进程吧，但是每个页表都要记录该进程的各个页</p> <p>相对来说，下面的分段式就很好看啦~</p> <p><img src="/assets/img/OS19.27471043.png" alt="OS19"></p> <h4 id="_4-5-4-段式管理的特点"><a href="#_4-5-4-段式管理的特点" class="header-anchor">#</a> 4.5.4 段式管理的特点</h4> <p>缺点的话，就是连续式存储的一些缺点，但这个的话我们下面的段页式可以解决</p> <p>优点就不用说了，前面介绍好久了都~</p> <h4 id="_4-5-5-段页式存储管理方式"><a href="#_4-5-5-段页式存储管理方式" class="header-anchor">#</a> 4.5.5 段页式存储管理方式</h4> <p>使用分段的逻辑存储方式，加之以底层分页式存储方式，每个进程建立一个段表，每个段建立一个页表，当然，我们现在需要三次访存咯，不建立快表没法用的说</p> <p><img src="/assets/img/OS20.f4c4f4e4.png" alt="OS20"></p> <ul><li><p>共享的实现</p> <p>段页式和分段式是同样容易实现共享的，因为我们在逻辑层面上使用相同的段存储一段共享数据，在段表内只需要一项，而页表内也没有重复的，只需要该段与实际存储地址之间的映射关系</p></li></ul> <p>很好地结合了两者的优点，所以说，两者根本不冲突嘛，他们是两种层级上的方案，或者我们这么看</p> <table><thead><tr><th>逻辑\物理</th> <th>连续</th> <th>分页</th></tr></thead> <tbody><tr><td>不分段</td> <td>连续分配</td> <td>分页式</td></tr> <tr><td>分段</td> <td>分段式</td> <td>段页式</td></tr></tbody></table> <p>嗯，我们所学的四种，大概就是这样的关系~</p> <p>只不过逻辑分段与物理分页有着相似的实现方式，所以我们可能会认为他们是相同层级的方式，从原因与涉及的层面来看，它们并无太大关系</p> <h3 id="_4-6-虚拟存储器的基本概念"><a href="#_4-6-虚拟存储器的基本概念" class="header-anchor">#</a> 4.6 虚拟存储器的基本概念</h3> <p>前面所述的存储方式虽然实现了非连续存储，进而提高了内存的利用率，但每次都还是将整个进程装入内存，下面有个更逆天的方式，极大地提高内存利用率，那就是虚拟存储器</p> <p>为什么需要虚拟存储器？因为我们的整个程序往往是很大的，很容易就将内存撑爆了，根据局部性原理，我们可以只将当前运行的部分调入内存，这样就可以大大降低内存臃肿的状态啦</p> <h4 id="_4-6-1-虚拟存储器的引入"><a href="#_4-6-1-虚拟存储器的引入" class="header-anchor">#</a> 4.6.1 虚拟存储器的引入</h4> <ul><li><p>局部性原理</p> <ul><li>时间局部性</li> <li>空间局部性</li></ul></li> <li><p>虚拟存储器定义</p> <p>基于局部性原理，应用程序在运行之前，没有必要全部装入内存，仅需将那些单前要运行的少数页面或段先装入内存便可运行，其余部分暂留在盘上</p> <ul><li>请求调页 如果要访问的页（段）在内存则直接执行；否则需要发生请求调页中断</li> <li>页面置换 若内存已满，则将暂时不用的页调入硬盘</li></ul></li> <li><p>虚拟存储器特征</p> <ul><li>多次性 多次调入</li> <li>对换性</li> <li>虚拟性 从逻辑上扩充内存容量</li></ul></li></ul> <h3 id="_4-7-请求分页存储管理方式"><a href="#_4-7-请求分页存储管理方式" class="header-anchor">#</a> 4.7 请求分页存储管理方式</h3> <p>需要扩展页表以支持请求分页存储</p> <table><thead><tr><th>页号</th> <th>物理块号</th> <th>状态位 P</th> <th>访问字段 A</th> <th>修改位 M</th> <th>外存地址</th></tr></thead> <tbody><tr><td>0</td> <td>10</td> <td>1</td> <td>1</td> <td>0</td> <td>120</td></tr> <tr><td>1</td> <td>14</td> <td>1</td> <td>0</td> <td>0</td> <td>123</td></tr> <tr><td>2</td> <td>15</td> <td>1</td> <td>2</td> <td>0</td> <td>134</td></tr> <tr><td>3</td> <td>-</td> <td>0</td> <td>-</td> <td>-</td> <td>135</td></tr></tbody></table> <h4 id="_4-7-1-请求分页中的硬件支持"><a href="#_4-7-1-请求分页中的硬件支持" class="header-anchor">#</a> 4.7.1 请求分页中的硬件支持</h4> <ul><li><p>页表机制</p> <p>其中各字段说明：</p> <ul><li>状态位 P ：该页是否调入内存</li> <li>访问字段 A ： 本页在一段时间内被访问的次数，作为选择换出页面参考</li> <li>修改位 M ： 记录调入内存后是否被修改过，如果被修改过，换出时需要重新写入内存</li> <li>外存地址</li></ul></li> <li><p>缺页中断机构</p> <p>请求分页时，需要的页不在内存时，产生缺页中断</p> <p>与一般中断的区别</p> <ul><li>在指令<strong>执行期间</strong>产生和处理中断信号</li> <li><strong>一条指令</strong>在执行期间可能产生<strong>多次</strong>缺页中断，比如该指令本身跨两个页，所需要的两个数据块分别又跨两个页，共产生 6 次缺页中断</li></ul></li> <li><p>地址变换机构</p></li></ul> <h4 id="_4-7-2-内存分配策略和分配算法"><a href="#_4-7-2-内存分配策略和分配算法" class="header-anchor">#</a> 4.7.2 内存分配策略和分配算法</h4> <ul><li><p>最小物理块数的确定</p> <p>保证进程正常运行的最小物理块数</p></li> <li><p>内存分配策略
分配策略分为固定和可变分配策略，而置换时还有全局置换和局部置换两种置换策略</p> <ul><li><p>固定分配局部置换</p> <p>每个进程分配固定数量的物理块</p></li> <li><p>可变分配全局置换</p> <p>进程的物理块数可动态调整，当所需页不在内存时，从<strong>空闲内存或者其他进程内存</strong>选择一块换出，即该进程内存空间会增加</p></li> <li><p>可变分配局部置换</p> <p>进程物理块数仍可动态调整，发生缺页中断从<strong>该进程内存</strong>中选择一页换出，当频繁发生缺页中断时，才可以为该进程增加物理块数，反之，若缺页率特别低，则可适当减少该进程物理块数</p></li></ul></li> <li><p>物理块分配算法</p> <ul><li>平均分配算法 所有进程分配的物理块数一样，很明显不公平</li> <li>按比例分配算法 按照进程大小按比例分配</li> <li>考虑优先权的分配算法 在按比例分配算法基础上考虑重要的紧急的任务，可为该类任务额外分配物理块以使之更快地完成任务</li></ul></li></ul> <h4 id="_4-7-3-调页策略"><a href="#_4-7-3-调页策略" class="header-anchor">#</a> 4.7.3 调页策略</h4> <ul><li><p>调入页面的时机</p> <ul><li>预调页策略 额外调入连续的几页</li> <li>请求调页策略 当发现不在内存时，调入该页</li></ul></li> <li><p>确定从何处调入页面</p> <div class="custom-block tip"><p class="custom-block-title">TIP</p> <p>外存分为</p> <ul><li>文件区 离散的分配方式，读写慢</li> <li>对换区 连续的分配方式，读写快</li></ul></div> <ul><li>系统拥有足够的对换区空间，可全部从对换区调入所需页面</li> <li>系统缺少足够的对换区空间，需要修改的放到对换区，以便需要时从对换区调入</li> <li>UNIX 方式，未运行的从文件区调入，运行过换出到对换区，下次可直接从对换区调入（甚至可能已经被其他进程调入内存）</li></ul></li> <li><p>页面调入过程</p> <p>访问需考虑是否缺页、换出需考虑是否修改过</p></li> <li><p>缺页率</p></li></ul> <h3 id="_4-8-页面置换算法"><a href="#_4-8-页面置换算法" class="header-anchor">#</a> 4.8 页面置换算法</h3> <h4 id="_4-8-1-最佳置换算法和先进先出算法"><a href="#_4-8-1-最佳置换算法和先进先出算法" class="header-anchor">#</a> 4.8.1 最佳置换算法和先进先出算法</h4> <ul><li><p>最佳（Optimal）置换算法</p> <p>每次换出的页应该是以后永不使用的或在最长（未来）时间内不再被访问的页面，很明显，我们并无法得知这样的页面是哪个，所以该算法仅仅是理论上的算法，虽然无法实现，但可以据此评估其他算法</p></li> <li><p>先入先出（FIFO）页面置换算法</p> <p>顾名思义，每次换出在内存中驻留时间最久的页面，可以为内存中的页面设置一个链表很容易地实现</p></li></ul> <h4 id="_4-8-2-最近最久未使用（lru）置换算法"><a href="#_4-8-2-最近最久未使用（lru）置换算法" class="header-anchor">#</a> 4.8.2 最近最久未使用（LRU）置换算法</h4> <p>选择<strong>最近最久未使用</strong>的页面予以淘汰，可为每个页面赋予一个访问字段进行实现</p> <ul><li>硬件支持
<ul><li>寄存器 用位记录最近访问行为，每次右移，若该次访问了则将最左位置 1 ，故每次只需淘汰值最小的即可</li> <li>栈 用于记录访问页面，访问之后放到栈顶，置换时从栈底置换</li></ul></li></ul> <h4 id="_4-8-3-clock-置换算法"><a href="#_4-8-3-clock-置换算法" class="header-anchor">#</a> 4.8.3 Clock 置换算法</h4> <ul><li><p>简单的 Clock 置换算法</p> <p>LRU 算法的一种近似算法，在页表内设一个访问位，另外设一替换指针，以免每次从头扫描</p> <ul><li>访问页面后，将该页面访问位置 1</li> <li>缺页导致需要扫描时，从替换指针向后扫描，若该页面访问位为 1 ，则将其置 0，若为 0 ，则替换出去</li></ul></li> <li><p>改进型 Clock 置换算法</p> <p>由于修改过的页需要写回磁盘，所以置换修改过的页代价相对会高些，所以该算法在考虑访问位的基础上，考虑到了修改位，在访问位一致的情况下，优先淘汰修改位为 0 的页面</p> <p>具体实现就是多扫描几次，开销增大不少</p></li></ul> <h3 id="_4-9-请求分段存储管理方式"><a href="#_4-9-请求分段存储管理方式" class="header-anchor">#</a> 4.9 请求分段存储管理方式</h3> <p>类似于请求分页，但是有少许的区别，该方式会更容易实现共享与保护</p> <h4 id="_4-9-1-分段的共享与保护"><a href="#_4-9-1-分段的共享与保护" class="header-anchor">#</a> 4.9.1 分段的共享与保护</h4> <ul><li><p>共享</p> <p>可使用共享段表来实现，可内记录共享段以及相应进程信息</p></li> <li><p>保护</p> <ul><li>越界检查</li> <li>存储控制检查 在段表表项中设存取控制字段</li></ul></li></ul> <blockquote><p><a href="https://github.com/SigureMo/notev/tree/master/Codes/OS/memory_management/" target="_blank" rel="noopener noreferrer">作业<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h2 id="_5-设备管理"><a href="#_5-设备管理" class="header-anchor">#</a> 5 设备管理</h2> <h3 id="_5-1-i-o-系统"><a href="#_5-1-i-o-系统" class="header-anchor">#</a> 5.1 I/O 系统</h3> <p>I/O 很容易成为系统性能的瓶颈，而且多而杂，甚至一个操作系统的 2/3 代码都是 I/O 相关代码</p> <h4 id="_5-1-1-i-o-设备"><a href="#_5-1-1-i-o-设备" class="header-anchor">#</a> 5.1.1 I/O 设备</h4> <ul><li>分类
<ul><li>按设备的使用特性分类
<ul><li>存储设备</li> <li>输入/输出设备</li></ul></li> <li>按传输速率分类
<ul><li>低速设备</li> <li>中速设备</li> <li>高速设备</li></ul></li> <li>按信息交换的单位分类
<ul><li>字符设备 以字节为单位，如打印机</li> <li>块设备 以块为单位，如磁盘</li></ul></li> <li>按设备的共享属性分类
<ul><li>独占设备（临界资源）</li> <li>共享设备</li> <li>虚拟设备</li></ul></li></ul></li></ul> <h3 id="_5-2-i-o-控制（数据传输）方式"><a href="#_5-2-i-o-控制（数据传输）方式" class="header-anchor">#</a> 5.2 I/O 控制（数据传输）方式</h3> <ul><li>四种 I/O 控制方式（组原里讲的那些）
<ul><li>程序 I/O 方式（循环等待，Polling）</li> <li>中断驱动 I/O 方式（Interrupts）</li> <li>直接存储器存取（DMA）</li> <li>I/O 通道控制方式（Channel）</li></ul></li></ul> <h3 id="_5-3-缓冲管理"><a href="#_5-3-缓冲管理" class="header-anchor">#</a> 5.3 缓冲管理</h3> <h4 id="_5-3-1-缓冲的引入"><a href="#_5-3-1-缓冲的引入" class="header-anchor">#</a> 5.3.1 缓冲的引入</h4> <ul><li>缓和 CPU 与 I/O 设备间速度不匹配的矛盾</li> <li>减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制</li> <li>提高 CPU 和 I/O 设备之间的并行性</li></ul> <h4 id="_5-3-2-单缓冲和双缓冲"><a href="#_5-3-2-单缓冲和双缓冲" class="header-anchor">#</a> 5.3.2 单缓冲和双缓冲</h4> <ul><li>单缓冲
<img src="/assets/img/OS21.387e0d3b.png" alt="OS21"></li> <li>双缓冲
<img src="/assets/img/OS22.dcbfe065.png" alt="OS22"></li></ul> <h4 id="_5-3-3-循环缓冲"><a href="#_5-3-3-循环缓冲" class="header-anchor">#</a> 5.3.3 循环缓冲</h4> <p><img src="/assets/img/OS23.f3020a6f.png" alt="OS23"></p> <h4 id="_5-3-4-缓冲池"><a href="#_5-3-4-缓冲池" class="header-anchor">#</a> 5.3.4 缓冲池</h4> <p><img src="/assets/img/OS24.9c7ab35d.png" alt="OS24"></p> <h3 id="_5-4-i-o-软件"><a href="#_5-4-i-o-软件" class="header-anchor">#</a> 5.4 I/O 软件</h3> <h4 id="_5-4-1-i-o-软件的设计目标和原则"><a href="#_5-4-1-i-o-软件的设计目标和原则" class="header-anchor">#</a> 5.4.1 I/O 软件的设计目标和原则</h4> <ul><li>与具体设备无关 上层的操作不应该考虑底层到底是什么设备</li> <li>统一命名 对设备进行统一逻辑命名</li> <li>对错误的处理 低层软件能够解决的错误就不让高层软件感知</li> <li>缓冲技术 向高层提供相同大小的数据块或字符单元</li> <li>设备的分配和释放 进程管理问题，防止死锁的发生</li> <li>I/O 控制方式 I/O 软件应向高层软件提供统一的操作接口</li></ul> <p><img src="/assets/img/OS25.aa30f5b2.png" alt="OS25"></p> <h4 id="_5-4-2-用户层的-i-o-软件"><a href="#_5-4-2-用户层的-i-o-软件" class="header-anchor">#</a> 5.4.2 用户层的 I/O 软件</h4> <p>需要通过系统调用获得操作系统服务（可通过库函数实现）</p> <h4 id="_5-4-3-设备独立性软件"><a href="#_5-4-3-设备独立性软件" class="header-anchor">#</a> 5.4.3 设备独立性软件</h4> <p>应用程序独立于具体使用的物理设备</p> <ul><li>在应用程序中，使用逻辑设备名称来请求使用某类设备</li> <li>系统在实际执行时，还必须使用物理设备名称</li></ul> <p>这就需要操作系统能够完成这种转换功能</p> <p>这可以带来以下好处</p> <ul><li>设备分配时的灵活性</li> <li>易于实现 I/O 重定向</li></ul> <p>设备独立性软件功能主要有</p> <ul><li>执行所有设备的公有操作</li> <li>向用户层（或文件层）软件提供统一接口</li></ul> <p>逻辑设备名到物理设备名映射的实现</p> <p>使用逻辑设备表（LUT），内含逻辑设备名、物理设备名、设备驱动程序的入口地址</p> <h4 id="_5-4-4-设备驱动程序"><a href="#_5-4-4-设备驱动程序" class="header-anchor">#</a> 5.4.4 设备驱动程序</h4> <p>I/O 进程与设备控制器之间的通信程序</p> <p>功能：</p> <ul><li>接收由设备独立性软件发来的命令和参数</li> <li>检查用户 I/O 请求的合法性</li> <li>发出 I/O 命令</li> <li>及时响应由控制器或通道发来的中断请求</li> <li>对于设置有通道的计算机系统，驱动程序还应能够根据用户的 I/O 请求，自动地构成通道程序</li></ul> <p>特点：</p> <ul><li>设备驱动程序主要是指在请求 I/O 的进程与设备控制器间的一个通信和转换程序</li> <li>驱动程序与设备控制器和 I/O 设备的硬件特性紧密相关，因而对不同类型的设备一个配置不同而驱动程序</li> <li>驱动程序与 I/O 设备所采用的 I/O 空盒子方式紧密相关</li> <li>由于驱动程序与硬件紧密相关，因而其中的一部分必须用汇编语言书写</li></ul> <h4 id="_5-4-5-中断处理程序"><a href="#_5-4-5-中断处理程序" class="header-anchor">#</a> 5.4.5 中断处理程序</h4> <ul><li>唤醒被阻塞的驱动（程序）进程</li> <li>保护被中断进程的 CPU 环境</li> <li>转入相应的设备处理程序</li> <li>中断处理</li> <li>恢复被中断进程的现场</li></ul> <h3 id="_5-5-设备分配"><a href="#_5-5-设备分配" class="header-anchor">#</a> 5.5 设备分配</h3> <h4 id="_5-5-1-设备分配中的数据结构"><a href="#_5-5-1-设备分配中的数据结构" class="header-anchor">#</a> 5.5.1 设备分配中的数据结构</h4> <ul><li>系统设备表（SDT， 整个系统一张）：设备名、设备控制块指针</li> <li>设备控制块（DCT， 每设备一张）：设备状态、分配状态、等待队列、控制器控制块指针</li> <li>控制器控制块（COCT， 每控制器一张）：控制器状态、等待队列、通道控制块、指针</li> <li>通道控制块（CHCT， 每通道一张）：通道状态、等待序列</li></ul> <p><img src="/assets/img/OS26.38db0201.png" alt="OS26"></p> <h4 id="_5-5-2-设备分配时应考虑的因素"><a href="#_5-5-2-设备分配时应考虑的因素" class="header-anchor">#</a> 5.5.2 设备分配时应考虑的因素</h4> <ul><li><p>设备的固有属性</p> <ul><li>独占性（是否是临界资源）</li> <li>共享性</li> <li>可虚拟设备</li></ul></li> <li><p>设备分配算法</p> <ul><li>先来先服务</li> <li>优先级高者优先</li></ul></li></ul> <h4 id="_5-5-3-独占设备的分配程序"><a href="#_5-5-3-独占设备的分配程序" class="header-anchor">#</a> 5.5.3 独占设备的分配程序</h4> <ul><li>基本的设备分配程序
<ul><li>分配设备</li> <li>分配控制器</li> <li>分配通道</li></ul></li> <li>设备分配程序的改进
<ul><li>增加设备的独立性 使用逻辑设备名而非物理设备名</li> <li>考虑多通路情况</li></ul></li></ul> <h4 id="_5-5-4-spooling-技术"><a href="#_5-5-4-spooling-技术" class="header-anchor">#</a> 5.5.4 SPOOLing 技术</h4> <p>为了缓和 CPU 的高速性与 I/O 设备低速型之间的矛盾而引入了脱机输入、脱机输出技术，使用专门控制的外围机将低速 I/O 设备上的数据传送到高速磁盘上</p> <p>SPOOLing 技术由脱机输入输出技术发展而来，使用输入进程和输出进程替代其中的输入处理器和输出处理器</p> <ul><li>组成
<img src="/assets/img/OS27.69994fe1.png" alt="OS27"> <ul><li>输入井和输出井</li> <li>输入缓冲区和输出缓冲区</li> <li>输入进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><msub><mi>P</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">SP_I</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和输出进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><msub><mi>P</mi><mi>O</mi></msub></mrow><annotation encoding="application/x-tex">SP_O</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">O</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li></ul></li> <li>特点
<ul><li>提高了 I/O 的速度</li> <li>将独占设备改造为共享设备</li> <li>实现了虚拟设备功能</li></ul></li></ul> <h3 id="_5-6-磁盘存储器的管理"><a href="#_5-6-磁盘存储器的管理" class="header-anchor">#</a> 5.6 磁盘存储器的管理</h3> <h4 id="_5-6-1-磁盘性能简述"><a href="#_5-6-1-磁盘性能简述" class="header-anchor">#</a> 5.6.1 磁盘性能简述</h4> <p><img src="/assets/img/OS28.2569d7d1.png" alt="OS28"></p> <ul><li><p>数据的组织和格式</p> <ul><li>每个磁盘片分一个或两个存储面</li> <li>每个磁盘面被组织成若干个同心环，这种环称为磁道（同一半径的磁道总和称为柱面）</li> <li>每条磁道又被逻辑上划分为若干个扇区</li></ul> <blockquote><p>当然，这样的话，就会有一个三维的物理地址 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>h</mi><mo separator="true">,</mo><mi>s</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c, h, s)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span> 与一维的块号 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span> 之间的转换关系，简单的进制转换算法，不赘述</p></blockquote></li> <li><p>磁盘的类型</p> <ul><li>固定头磁盘 每个磁道一个磁头，不需移臂</li> <li>移动头磁盘 只在每个盘面配有一个磁头，需要移臂</li></ul></li> <li><p>磁盘访问时间</p> <blockquote><p>地址：柱面号、磁头号、扇区号</p></blockquote> <ul><li>柱面定位时间 花费时间最多</li> <li>旋转延迟时间</li> <li>数据传送时间</li></ul></li></ul> <h4 id="_5-6-2-磁盘调度"><a href="#_5-6-2-磁盘调度" class="header-anchor">#</a> 5.6.2 磁盘调度</h4> <ul><li><p>先来先服务 FCFS</p></li> <li><p>最短寻道时间优先 SSTF</p> <p>每次都找离当前磁头最近的磁道</p></li> <li><p>扫描 SCAN</p> <p>为避免 SSTF 所带来的“饥饿”现象，使用类似于电梯的算法，每次都先沿一个方向走到最后一个（并非尽头），然后再改变方向</p></li></ul> <h4 id="_5-6-3-磁盘高速缓存"><a href="#_5-6-3-磁盘高速缓存" class="header-anchor">#</a> 5.6.3 磁盘高速缓存</h4> <ul><li><p>磁盘高速缓存的形式</p> <p>将内存上的一部分存储空间作为磁盘的 Cache 使用，会缓存一些最近用过的从磁盘中取出的盘快，逻辑上属于磁盘、物理上是驻留在内存中的盘块</p></li> <li><p>数据交付方式</p> <ul><li>缓存中有，则从缓存中取</li> <li>若无，则从盘中取出，并存入缓存</li></ul></li> <li><p>置换算法 类似于请求调页算法中的置换算法，比如 LRU，下面列举一些不同点</p> <ul><li>访问频率 对联想寄存器的访问频率远远高于对高速缓存的访问频率</li> <li>可预见性 高速缓存中对于哪些数据是会再次访问是有一定的可预见性的</li> <li>数据的一致性 出现问题时使得缓存与磁盘之间未同步的问题</li> <li>周期性地写回磁盘 按照 LRU 算法，经常使用的数据块是不会写回磁盘的，如果此时发生了故障，数据是会丢失的，所以我们可以周期性地写回磁盘以避免该问题</li></ul></li></ul> <h4 id="_5-6-4-提高磁盘-i-o-速度的其他方法"><a href="#_5-6-4-提高磁盘-i-o-速度的其他方法" class="header-anchor">#</a> 5.6.4 提高磁盘 I/O 速度的其他方法</h4> <ul><li>提前读 当要读取文件的时候，由于大多采用顺序访问，故可提前读取下一个盘块数据</li> <li>延迟写 有很大概率在不久之后再次访问</li> <li>优化物理块的分布</li></ul> <h2 id="_6-文件管理"><a href="#_6-文件管理" class="header-anchor">#</a> 6 文件管理</h2> <h3 id="_6-1-文件与文件系统"><a href="#_6-1-文件与文件系统" class="header-anchor">#</a> 6.1 文件与文件系统</h3> <h4 id="_6-1-1-文件的概念"><a href="#_6-1-1-文件的概念" class="header-anchor">#</a> 6.1.1 文件的概念</h4> <ul><li><p>定义</p> <p>文件是计算机系统中信息存放的一种组织形式</p></li> <li><p>文件的属性</p> <p>用于系统对文件进行管理，常见属性如下</p> <ul><li>保护信息</li> <li>创建者</li> <li>只读标志位</li> <li>隐藏标志位</li> <li>系统标志位</li> <li>创建时间、最后访问时间、最后修改时间</li> <li>文件长度</li></ul></li></ul> <h4 id="_6-1-2-文件的类型"><a href="#_6-1-2-文件的类型" class="header-anchor">#</a> 6.1.2 文件的类型</h4> <ul><li>以文件的性质和用途分类
<ul><li>系统文件</li> <li>库文件</li> <li>用户文件</li></ul></li> <li>按文件的存取控制属性分类
<ul><li>只读文件</li> <li>读写文件</li> <li>执行文件</li></ul></li> <li>按文件的组织形式分类
<blockquote><p>UNIX 依此组织文件</p></blockquote> <ul><li>普通文件</li> <li>目录文件 由文件目录项组成的文件</li> <li>特别文件 将设备作为文件进行管理</li></ul></li></ul> <h4 id="_6-1-3-文件的操作"><a href="#_6-1-3-文件的操作" class="header-anchor">#</a> 6.1.3 文件的操作</h4> <ul><li>建立文件</li> <li>打开文件</li> <li>读文件</li> <li>写文件</li> <li>关闭文件</li> <li>删除文件</li> <li>文件指针定位</li></ul> <h4 id="_6-1-4-文件系统"><a href="#_6-1-4-文件系统" class="header-anchor">#</a> 6.1.4 文件系统</h4> <p>OS 中负责处理文件相关事宜的程序和数据结构，包括文件的查找、存放、保护、共享、命名、文件常用操作的实现以及文件存储器的管理等等</p> <h3 id="_6-2-文件结构与存储设备"><a href="#_6-2-文件结构与存储设备" class="header-anchor">#</a> 6.2 文件结构与存储设备</h3> <h4 id="_6-2-1-文件的逻辑结构"><a href="#_6-2-1-文件的逻辑结构" class="header-anchor">#</a> 6.2.1 文件的逻辑结构</h4> <ul><li>流式文件（无结构文件） 基本信息单位是字节或字，其长度是所含字节的数量
<blockquote><p>UNIX 中，所有的文件都被看做是流式文件，即便是有结构文件，也被视为流式文件，系统不对文件进行格式处理</p></blockquote></li> <li>记录式文件（有结构文件） 是一种结构文件，由若干个记录组成
<ul><li>定长记录 处理方便，开销小</li> <li>变长记录</li></ul></li></ul> <h4 id="_6-2-2-文件的存取方法"><a href="#_6-2-2-文件的存取方法" class="header-anchor">#</a> 6.2.2 文件的存取方法</h4> <ul><li>顺序存取</li> <li>随机存取（直接存取）</li> <li>按键存取 使用 Hash 进行索引存取</li></ul> <h4 id="_6-2-3-文件的物理结构"><a href="#_6-2-3-文件的物理结构" class="header-anchor">#</a> 6.2.3 文件的物理结构</h4> <ul><li><p>连续结构 文件的全部信息存放在外存的一片连续编号的物理块中</p> <ul><li>优点 简单，支持顺序存取和随机存取</li> <li>缺点 文件不易动态增长，预留空间浪费，不利于文件的插入和删除，存在外部碎片问题</li></ul></li> <li><p>串联结构（链接结构） 非连续的结构，存放文件信息的每一<strong>物理块中有一个指针</strong>，指向下一个物理块</p> <ul><li><p>优点</p> <ul><li>提高了磁盘空间利用率</li> <li>有利于文件插入和删除</li> <li>有利于文件动态扩充</li></ul></li> <li><p>缺点</p> <ul><li>存取速度慢，不适合随机存取</li> <li>链接指针占用一定的空间</li> <li>可靠性问题，如指针出错</li></ul></li></ul></li> <li><p>索引结构 文件信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构——索引表，并将这些块的块号存放在索引表中</p> <blockquote><p>注意，索引表也是存在物理块中的，我们使用 <code>open</code> （比如 <code>C</code> 啦， <code>Python</code> 啦）操作实际是将该文件的索引表加载到内存中</p></blockquote> <p><img src="/assets/img/OS29.0a265769.png" alt="OS29"></p> <ul><li><p>优点</p> <ul><li>保持了链接结构的优点又解决了其缺点，能顺序存取，又能随机存取</li> <li>满足了文件动态增长，插入删除的要求</li> <li>能充分利用外存空间</li></ul></li> <li><p>缺点</p> <ul><li><p>索引表本身带来了系统开销，如：内外存空间，存取时间开销等</p> <blockquote><p>当索引表本身很大时，可考虑建立多级索引</p></blockquote> <p><img src="/assets/img/OS30.3a3517bb.png" alt="OS30"></p></li></ul></li></ul></li> <li><p>混合索引结构（多重索引，UNIX 采用）
<img src="/assets/img/OS31.24476796.png" alt="OS31"></p> <p>首先假设一个磁盘块 <code>512 Bytes</code> ，可存储 <code>128</code> 个 <code>4 Bytes</code> 的索引号，我们将主索引表分为以下区域</p> <ul><li>直接地址 使用 10 个直接地址项，如果文件小于 <code>10 * 512 Bytes</code> ，就用不到后面的啦</li> <li>一次间接地址 当超过十个直接地址项所能索引的大小时，一次间接地址指向一个磁盘块，将其作为索引表，很明显，我们又可以索引 <code>128</code> 个磁盘块，此时最大索引 <code>10 + 128</code> 个磁盘块</li> <li>多次间接地址 上述地址不足，则需要继续使用更高级的索引表……</li></ul></li></ul> <h4 id="_6-2-4-文件的存储设备"><a href="#_6-2-4-文件的存储设备" class="header-anchor">#</a> 6.2.4 文件的存储设备</h4> <p>磁带、磁盘、光盘、闪存 ……</p> <h3 id="_6-3-文件目录管理"><a href="#_6-3-文件目录管理" class="header-anchor">#</a> 6.3 文件目录管理</h3> <h4 id="_6-3-1-文件控制块与文件目录"><a href="#_6-3-1-文件控制块与文件目录" class="header-anchor">#</a> 6.3.1 文件控制块与文件目录</h4> <ul><li><p>目录项（文件控制块，FCB） 用于记录文件相关信息
<img src="/assets/img/OS32.ca6a056c.png" alt="OS32"></p> <p>将真正的文件属性存储在 iNode 中，更容易实现文件共享的操作</p> <p><img src="/assets/img/OS33.f701f81e.png" alt="OS33"></p> <p>如果只有根目录 inode 在内存，那么还需要读取根目录的目录文件，s1 i_node ，s1 目录的目录文件，...，经过 6 次磁盘读取得到 file1 i_node ，之后需要读取 5 次磁盘，即最多共 11 次，如果 file1 i_node 已经在内存，只需要读取 5 次磁盘即可</p></li></ul> <h4 id="_6-3-2-目录结构"><a href="#_6-3-2-目录结构" class="header-anchor">#</a> 6.3.2 目录结构</h4> <ul><li>单级目录结构</li> <li>二级目录结构</li> <li>多级目录结构 树形</li></ul> <h3 id="_6-4-文件存储空间管理"><a href="#_6-4-文件存储空间管理" class="header-anchor">#</a> 6.4 文件存储空间管理</h3> <h4 id="_6-4-1-空闲表法"><a href="#_6-4-1-空闲表法" class="header-anchor">#</a> 6.4.1 空闲表法</h4> <p>每个文件分配一块<strong>连续</strong>的存储空间，外存的所有空闲区建立一张空闲表</p> <p><img src="data:image/png;base64,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" alt="OS34"></p> <h4 id="_6-4-2-空闲链表法"><a href="#_6-4-2-空闲链表法" class="header-anchor">#</a> 6.4.2 空闲链表法</h4> <p>用链表来表示磁盘的空闲空间列表</p> <ul><li><p>空闲盘块链</p> <p><img src="/assets/img/OS35.d4e40b5c.png" alt="OS35"></p></li> <li><p>空闲盘区链</p></li></ul> <h4 id="_6-4-3-位示图"><a href="#_6-4-3-位示图" class="header-anchor">#</a> 6.4.3 位示图</h4> <p>以位示图来表征空闲区，可分配连续的区域，但是占用额外的空间</p> <p><img src="/assets/img/OS36.a69fe737.png" alt="OS36"></p> <h4 id="_6-4-4-成组链接法"><a href="#_6-4-4-成组链接法" class="header-anchor">#</a> 6.4.4 成组链接法</h4> <p>UNIX 内采用的方法，使用空闲盘块号栈进行分配回收</p> <h3 id="_6-5-文件的共享"><a href="#_6-5-文件的共享" class="header-anchor">#</a> 6.5 文件的共享</h3> <ul><li>外存共享 （用户）</li> <li>内存共享 （进程）</li></ul> <h3 id="_6-6-文件的保护、保密与安全"><a href="#_6-6-文件的保护、保密与安全" class="header-anchor">#</a> 6.6 文件的保护、保密与安全</h3> <h4 id="_6-6-1-文件的存取控制"><a href="#_6-6-1-文件的存取控制" class="header-anchor">#</a> 6.6.1 文件的存取控制</h4> <ul><li>存取控制矩阵 存储占用大，验证费时</li> <li>存取控制表</li></ul> <h4 id="_6-6-2-文件的保密"><a href="#_6-6-2-文件的保密" class="header-anchor">#</a> 6.6.2 文件的保密</h4> <ul><li>口令</li> <li>密码</li></ul> <h1 id="experiment"><a href="#experiment" class="header-anchor">#</a> Experiment</h1> <p><a href="https://github.com/SigureMo/notev/tree/master/Codes/OS/Experiment" target="_blank" rel="noopener noreferrer">本课程配套实验<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h1 id="change-log"><a href="#change-log" class="header-anchor">#</a> Change Log</h1> <ol><li>190311 #1 Finished</li> <li>190326 <a href="https://github.com/SigureMo/notev/tree/master/Codes/OS/process_sync" target="_blank" rel="noopener noreferrer">process_sync<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> Finished</li> <li>190404 #2 Finished</li> <li>190418 #3 Finished</li> <li>190513 #4 Finished</li> <li>190523 #5 Finished</li> <li>190530 #6 Finished</li></ol> <h1 id="reference"><a href="#reference" class="header-anchor">#</a> Reference</h1> <ol><li>杨志豪老师课程及其<a href="http://faculty.dlut.edu.cn/zhyang_CS/zh_CN/jxzy/749840/content/1641.htm" target="_blank" rel="noopener noreferrer">配套课件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>《计算机操作系统》 汤小丹 梁红兵 哲凤屏 汤子瀛</li></ol></div></article> <section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      Created : 2019-02-28
    </span> <span class="update-date" data-v-4e23451f>
      Updated : 2020-05-18
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2018/11/21/solid-state-phase-transformation.html" class="post-link" data-v-4e23451f>
      Previous Post : Solid-state Phase Transformation
    </a> <a href="/posts/2019/04/25/discrete-mathematics.html" class="post-link" data-v-4e23451f>
      Next Post : Discrete Mathematics
    </a></section></section> <div id="post-comments" class="main-div"><!----></div></div></main> <aside class="aside" data-v-4dd605a1><div class="info-card main-div" data-v-9d847660 data-v-4dd605a1><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(/info_bg.jpg);" data-v-9d847660><img src="/sigure_mo.png" alt="SigureMo" class="info-avatar" data-v-9d847660></div> <div class="info-card-body" data-v-9d847660><section class="info-nickname" data-v-9d847660>
      SigureMo
    </section> <section class="info-desc" data-v-9d847660>喵喵喵？</section> <section class="info-contact" data-v-9d847660><section data-v-9d847660><span title="DLC, China" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>DLC, China</title><use xlink:href="#icon-location" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          DLC, China
        </span></span></section> <section data-v-9d847660><span title="Dalian University of Technology" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>Dalian University of Technology</title><use xlink:href="#icon-organization" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          Dalian University of Technology
        </span></span></section> <section data-v-9d847660><a href="mailto:sigure.qaq@gmail.com" title="sigure.qaq@gmail.com" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>sigure.qaq@gmail.com</title><use xlink:href="#icon-email" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          sigure.qaq@gmail.com
        </span></a></section></section></div> <div class="info-card-footer" data-v-9d847660><section class="info-sns clearfix" data-v-9d847660><a href="https://github.com/SigureMo" target="_blank" class="sns-link" data-v-9d847660><span title="GitHub: SigureMo" class="sns-icon" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1.5em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>GitHub: SigureMo</title><use xlink:href="#icon-github" data-v-9d847660 data-v-9d847660></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-4dd605a1><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>Table of Contents</span> <div class="post-nav-toc"><ul><li><a href="/posts/2019/02/28/operating-system.html#_1-操作系统引论">1 操作系统引论</a><ul><li><a href="/posts/2019/02/28/operating-system.html#_1-1-操作系统的目标和作用">1.1 操作系统的目标和作用</a></li><li><a href="/posts/2019/02/28/operating-system.html#_1-2-操作系统的发展过程">1.2 操作系统的发展过程</a></li><li><a href="/posts/2019/02/28/operating-system.html#_1-3-操作系统的特征">1.3 操作系统的特征</a></li><li><a href="/posts/2019/02/28/operating-system.html#_1-4-操作系统的五大功能">1.4 操作系统的五大功能</a></li><li><a href="/posts/2019/02/28/operating-system.html#_1-5-os-结构设计">1.5 OS 结构设计</a></li></ul></li><li><a href="/posts/2019/02/28/operating-system.html#_2-进程管理">2 进程管理</a><ul><li><a href="/posts/2019/02/28/operating-system.html#_2-1-进程的基本概念">2.1 进程的基本概念</a></li><li><a href="/posts/2019/02/28/operating-system.html#_2-2-进程控制">2.2 进程控制</a></li><li><a href="/posts/2019/02/28/operating-system.html#_2-3-进程同步">2.3 进程同步</a></li><li><a href="/posts/2019/02/28/operating-system.html#_2-4-经典进程的同步问题">2.4 经典进程的同步问题</a></li><li><a href="/posts/2019/02/28/operating-system.html#_2-5-进程通信">2.5 进程通信</a></li><li><a href="/posts/2019/02/28/operating-system.html#_2-6-线程的基本概念">2.6 线程的基本概念</a></li><li><a href="/posts/2019/02/28/operating-system.html#_2-7-线程的实现">2.7 线程的实现</a></li></ul></li><li><a href="/posts/2019/02/28/operating-system.html#_3-处理机调度与死锁">3 处理机调度与死锁</a><ul><li><a href="/posts/2019/02/28/operating-system.html#_3-1-处理机调度的层次">3.1 处理机调度的层次</a></li><li><a href="/posts/2019/02/28/operating-system.html#_3-2-调度队列模型和调度准则">3.2 调度队列模型和调度准则</a></li><li><a href="/posts/2019/02/28/operating-system.html#_3-3-调度算法">3.3 调度算法</a></li><li><a href="/posts/2019/02/28/operating-system.html#_3-4-实时调度">3.4 实时调度</a></li><li><a href="/posts/2019/02/28/operating-system.html#_3-5-产生死锁的原因和必要条件">3.5 产生死锁的原因和必要条件</a></li><li><a href="/posts/2019/02/28/operating-system.html#_3-6-预防死锁">3.6 预防死锁</a></li><li><a href="/posts/2019/02/28/operating-system.html#_3-7-避免死锁">3.7 避免死锁</a></li><li><a href="/posts/2019/02/28/operating-system.html#_3-8-死锁的检测与解除">3.8 死锁的检测与解除</a></li></ul></li><li><a href="/posts/2019/02/28/operating-system.html#_4-存储器管理">4 存储器管理</a><ul><li><a href="/posts/2019/02/28/operating-system.html#_4-1-存储器的层次结构">4.1 存储器的层次结构</a></li><li><a href="/posts/2019/02/28/operating-system.html#_4-2-程序的装入和链接">4.2 程序的装入和链接</a></li><li><a href="/posts/2019/02/28/operating-system.html#_4-3-连续分配方式">4.3 连续分配方式</a></li><li><a href="/posts/2019/02/28/operating-system.html#_4-4-基本分页存储管理方式">4.4 基本分页存储管理方式</a></li><li><a href="/posts/2019/02/28/operating-system.html#_4-5-分段存储管理方式">4.5 分段存储管理方式</a></li><li><a href="/posts/2019/02/28/operating-system.html#_4-6-虚拟存储器的基本概念">4.6 虚拟存储器的基本概念</a></li><li><a href="/posts/2019/02/28/operating-system.html#_4-7-请求分页存储管理方式">4.7 请求分页存储管理方式</a></li><li><a href="/posts/2019/02/28/operating-system.html#_4-8-页面置换算法">4.8 页面置换算法</a></li><li><a href="/posts/2019/02/28/operating-system.html#_4-9-请求分段存储管理方式">4.9 请求分段存储管理方式</a></li></ul></li><li><a href="/posts/2019/02/28/operating-system.html#_5-设备管理">5 设备管理</a><ul><li><a href="/posts/2019/02/28/operating-system.html#_5-1-i-o-系统">5.1 I/O 系统</a></li><li><a href="/posts/2019/02/28/operating-system.html#_5-2-i-o-控制（数据传输）方式">5.2 I/O 控制（数据传输）方式</a></li><li><a href="/posts/2019/02/28/operating-system.html#_5-3-缓冲管理">5.3 缓冲管理</a></li><li><a href="/posts/2019/02/28/operating-system.html#_5-4-i-o-软件">5.4 I/O 软件</a></li><li><a href="/posts/2019/02/28/operating-system.html#_5-5-设备分配">5.5 设备分配</a></li><li><a href="/posts/2019/02/28/operating-system.html#_5-6-磁盘存储器的管理">5.6 磁盘存储器的管理</a></li></ul></li><li><a href="/posts/2019/02/28/operating-system.html#_6-文件管理">6 文件管理</a><ul><li><a href="/posts/2019/02/28/operating-system.html#_6-1-文件与文件系统">6.1 文件与文件系统</a></li><li><a href="/posts/2019/02/28/operating-system.html#_6-2-文件结构与存储设备">6.2 文件结构与存储设备</a></li><li><a href="/posts/2019/02/28/operating-system.html#_6-3-文件目录管理">6.3 文件目录管理</a></li><li><a href="/posts/2019/02/28/operating-system.html#_6-4-文件存储空间管理">6.4 文件存储空间管理</a></li><li><a href="/posts/2019/02/28/operating-system.html#_6-5-文件的共享">6.5 文件的共享</a></li><li><a href="/posts/2019/02/28/operating-system.html#_6-6-文件的保护、保密与安全">6.6 文件的保护、保密与安全</a></li></ul></li></ul></div></div> <div class="post-nav-comments"><svg class="icon"><title>comment</title><use xlink:href="#icon-comment"></use></svg> <a href="/posts/2019/02/28/operating-system.html#post-comments">
      Comments
    </a></div></div></aside></div> <footer class="footer" data-v-1375e54c><p class="footer-sns-links" data-v-1375e54c><a href="https://github.com/SigureMo" target="_blank" class="sns-link" data-v-1375e54c><span title="GitHub: SigureMo" class="sns-icon" data-v-1375e54c data-v-1375e54c><svg class="icon" style="font-size:25px;" data-v-1375e54c data-v-1375e54c><title data-v-1375e54c data-v-1375e54c>GitHub: SigureMo</title><use xlink:href="#icon-github" data-v-1375e54c data-v-1375e54c></use></svg></span></a></p> <p class="footer-text" data-v-1375e54c><span data-v-1375e54c>Powered by </span> <a href="https://github.com/vuejs/vuepress" target="_blank" data-v-1375e54c>
      VuePress
    </a> <span data-v-1375e54c> | </span> <a href="https://github.com/meteorlxy/vuepress-theme-meteorlxy" target="_blank" data-v-1375e54c>
        meteorlxy
      </a></p> <p class="footer-text" data-v-1375e54c>Copyright 2018-present <a href="https://github.com/SigureMo" target="_blank">SigureMo</a> | MIT License</br><a href="http://www.beian.miit.gov.cn/" target="_blank">辽ICP备19014250号</a></p></footer></div><div class="global-ui"><!----><!----><!----><canvas id="vuepress-canvas-ribbon"></canvas><canvas id="vuepress-canvas-cursor"></canvas><div></div><div id="goTop" class="hide-cat" data-v-4973f866></div><APlayer audio="" fixed="true" theme="#b7daff" loop="loop" order="list" preload="auto" volume="0.7" mutex="true" lrc-type="3" list-max-height="250" storage-name="vuepress-plugin-meting"></APlayer></div></div>
    <script src="/assets/js/app.c177b168.js" defer></script><script src="/assets/js/20.880cff98.js" defer></script><script src="/assets/js/6.b268b72c.js" defer></script><script src="/assets/js/18.f17d4fe5.js" defer></script>
  </body>
</html>
