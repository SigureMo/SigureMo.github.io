(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{267:function(t,e,r){t.exports=r.p+"assets/img/C_and_pointer01.c7d734b0.png"},519:function(t,e,r){"use strict";r.r(e);var a=r(2),_=Object(a.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1-初识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-初识"}},[t._v("#")]),t._v(" 1 初识")]),t._v(" "),a("p",[t._v("不得不说，初学者学 C 语言的指针是很头疼的，时隔一年半重新学起 C 语言的我本以为这次已经很了解指针了，但是乍一学数据结构才发现，很多地方还是不得要领。")]),t._v(" "),a("h3",{attrs:{id:"_1-1-指针也是变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-指针也是变量"}},[t._v("#")]),t._v(" 1.1 指针也是变量")]),t._v(" "),a("p",[t._v("指针是变量，emmmmmmm，貌似是废话，但是我当初刚开始学 c 的时候感觉指针是一个神圣的东西，它可以指向一个变量，好神奇的样子，然后……学不懂不学了(╯‵□′)╯︵┻━┻")]),t._v(" "),a("p",[t._v("不过这次再回顾这里的知识我发现不过如此嘛，指针里面不过是保存了一个一已知类型的变量的"),a("strong",[t._v("地址")]),t._v("，至于这个地址多大嘛……看操作系统了，64 位占 8bytes，32 位占 4bytes，然后呐然后呐？知道地址能干嘛？知道地址当然就可以找到这个地址下的变量啦，哦对，应该只能找到 01 组成的一串字节码，而且还不知道要读多少字节才结束，这时候之前申明的类型就起作用啦，比如 char"),a("em",[t._v("就读 1byte，int")]),t._v("就读 4bytes 好啦。")]),t._v(" "),a("h3",{attrs:{id:"_1-2-知道了指针就可以为所欲为了哈哈"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-知道了指针就可以为所欲为了哈哈"}},[t._v("#")]),t._v(" 1.2 知道了指针就可以为所欲为了哈哈")]),t._v(" "),a("p",[t._v("Q: 咦？为啥要用指针，以前直接拿到变量不是挺好的嘛？也可以直接对变量操作呀。")]),t._v(" "),a("p",[t._v("A: 如果都在 main 函数里确实也看不出来啥，但是如果把数据传到函数内进行修改的话，就只能通过返回值修改了，而且 c 只能 return1 个啊，头疼。但是如果把指针传到函数里……嘿嘿，"),a("strong",[t._v("无论这个变量变成什么样子都能找到他，而且读写随你")]),t._v("。\n另外，向函数里面传一个结构体啦、数组啦都要将复制很大一部分数据，而 64 位指针也不过 8bytes，也是很经济的选择。")]),t._v(" "),a("h3",{attrs:{id:"_1-3-动态分配内存是什么鬼"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-动态分配内存是什么鬼"}},[t._v("#")]),t._v(" 1.3 动态分配内存是什么鬼")]),t._v(" "),a("p",[t._v("Q: 干嘛要动态分配内存啦，我不是已经声明了一个指针了变量和他的类型了嘛？干嘛还要再分配呀？")]),t._v(" "),a("p",[t._v("A: 但是"),a("strong",[t._v("不知道那个指针是指向哪里")]),t._v("的呀，变量里的值可是随机的，指针也是变量啊，一旦里面存了哪些不该指向的地址，然后再*p=blabla……就崩溃了……")]),t._v(" "),a("p",[t._v("Q: 那就给他改个可以指向的地址好了，干嘛 malloc？")]),t._v(" "),a("p",[t._v("A: 谁知道哪些地址可以指呀？已经知道的只有之前新建的变量，所以可以 p = &a 这样子，但是那也只能是管理变量 a 的值，"),a("strong",[t._v("如果 p 想要有一个属于自己的一片区域的话，要自己去申请那么一片区域，之后系统就会把地址给他，当然这个地址一定是可以指的")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"_2-结构体和对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-结构体和对象"}},[t._v("#")]),t._v(" 2 结构体和对象")]),t._v(" "),a("p",[t._v("当初只学过 C 的我去学 Python 是各种不适应面向对象，然后现在学完各种面向对象语言再回来学 C 又是各种的不适应……当学到结构体的时候我貌似找到了对象的影子，虽然不一样，但一方面我从底层了解到了对象，另一方面我从其他语言的对象了解了结构体的意义。")]),t._v(" "),a("h3",{attrs:{id:"_2-1-结构体可以保存各种不同的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-结构体可以保存各种不同的数据"}},[t._v("#")]),t._v(" 2.1 结构体可以保存各种不同的数据")]),t._v(" "),a("p",[t._v("面向对象最基础的例子就是创建一个拥有 name、age 的 Person 类啦，相应地，结构体自然也可以完成这种简单的结构，如果想增加一个函数作为专有方法也是可以的，但是为啥说结构体不是类呢？可能是因为类可以对数据进行封装，主学 Python 的我对这个的认识确实不深。但是无论如何，用 c 实现的面向对象语言底层一定是是使用结构体对数据集中保存的。")]),t._v(" "),a("h3",{attrs:{id:"_2-2-对象的赋值与创建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-对象的赋值与创建"}},[t._v("#")]),t._v(" 2.2 对象的赋值与创建")]),t._v(" "),a("p",[t._v("在学习 Java 的面向对象可以了解到对象和基本数据并不是一种东西，而且对象的赋值并不是和基础数据一样赋‘值’，而是和原来对象的变量一起管理其内数据。如果从其底层 c 来看的话，很明显"),a("strong",[t._v("对象的赋值只是传递指针")]),t._v("，而想要真正的新建一个对象的话，就要 new，用 c 来实现的话应该是 malloc 一个新的内存区域，让这个变量有一个自己管理的区域（对象）。\n但是稍稍学了一点 C++又发现 C++中对象的传递与其他面向对象语言完全不同，传值便是传值。C++中新定义了一种数据类型 Reference，是一种对数据取别名的操作，底层仍然是存储地址，并没新建新的数据单元，但却是可以直接使用引用对原数据进行读写，很像 Java 对象传递时候的操作，这样看的话，"),a("strong",[t._v("其他面向对象语言传递对象时候")]),t._v("说"),a("strong",[t._v("是传递 Reference")]),t._v("倒更为贴切些，归根结底都只是将原对象的地址存储起来啦ヽ(￣ ▽ ￣)ﾉ")]),t._v(" "),a("h2",{attrs:{id:"_3-内存的结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-内存的结构"}},[t._v("#")]),t._v(" 3 内存的结构")]),t._v(" "),a("p",[t._v("C 语言最大的魅力就是可以直接操作内存了，当然，这也是它最难懂的地方。之前就有在 C 语言课程中对内存的分配稍有了解，最近上过 C++与选修单片机才对内存有了进一步的了解。")]),t._v(" "),a("h3",{attrs:{id:"_3-1-再探指针"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-再探指针"}},[t._v("#")]),t._v(" 3.1 再探指针")]),t._v(" "),a("p",[t._v("指针果然是一个很神奇的东西，它可以保存一个地址，但是如果学了汇编的话对地址一定不会陌生，汇编中地址可是一个一个手动分配的……C 语言最大的方便就是将地址分配的问题交由编译器完成了，我们一般不需要接触到具体的地址。\n假期浏览过 C 语言进阶课程后，我对课中大地址小地址什么的一直不太明白，但是倒是明白了内存确实是有这么几个分区的，什么静态变量、局部变量等等不一定是放在一个地方的，有些是连续的，有些可能是在其他地方放着。但是经过这门课之后我大概知道了 malloc 出来的变量与指针本身并不是存在同一个地方的，有了这个基础，后面的就好理解了。")]),t._v(" "),a("h3",{attrs:{id:"_3-2-各区概况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-各区概况"}},[t._v("#")]),t._v(" 3.2 各区概况")]),t._v(" "),a("p",[t._v("先看图，来源看 Reference4")]),t._v(" "),a("p",[a("img",{attrs:{src:r(267),alt:""}})]),t._v(" "),a("p",[t._v("各区情况一目了然，下面主要分析一下我稍有了解的几个区")]),t._v(" "),a("ol",[a("li",[a("strong",[t._v("Stack")]),t._v("，栈区，很容易就能从图上看出来，栈区是从高地址向低地址扩张的。也就是说，如果该片内存空间连续，就可以发现连续两个 int 之间地址是差 4bytes，而且是倒序的，这个现象很熟悉呀，C 进阶课程里就多次提到过，而且很巧的是，栈的内存空间连续也必须连续，因为它正是按照栈的数据结构设计的。\n先进后出，或者说后进先出，这为函数的调用提供了很大的便利，也就体现了局部变量本身的特点，只在函数内部（入栈后）有效，而函数调用后（出栈）是无效的，这也解释了为何 return 局部变量指针是丝毫没有意义的，因为其内数据很容易被之后的入栈操作所覆盖掉。")]),t._v(" "),a("li",[a("strong",[t._v("Heap")]),t._v("，堆区，这是一片自由的区域，是我们真正自己操作的部分，但也正因为我们自己去操作，所以如果操作不好会对整个程序造成影响。\n之前多次提到了 malloc，但是 malloc 之后的数据域是在哪里呢，如果说在栈区的话，我们又是随时可以 free 的，这根本不满足后进先出的原则。没错啦，就是在这个堆区，我们可以通过 malloc 在堆区分配一个指定大小的内存空间，并将这个地址返回给某个指针，这个指针一般都是在栈区啦，这就解释了为啥他俩地址差那么多了。\n另外，堆区内存是可以向高地址扩张的，而 free 是只把那一小块 free 掉，如果多次 malloc、free 就会导致堆区的不连续，造成明明有剩余空间但是一些结构体放不下的现象，所以这个堆区还是要善加利用的。\n另外，一定要记住 free 哦，不然一方面可能导致内存空间不足，另一方面程序结束后堆区可不一定会被系统释放呦，这要看心情的( • ̀ω•́ )✧")]),t._v(" "),a("li",[a("strong",[t._v("Static")]),t._v("，静态区，放一些全局变量和静态变量的，放在低地址区。这些不能随便改哒。")]),t._v(" "),a("li",[t._v("blabla，其他的还不知道啦，不过基本都是不能动的，这也就说明了如果声明了一个指针后如果没赋值很容易 Boom! 啦，没赋值里面的数是随机的，然后对一个不知道的地址进行写入……很可能会崩溃的")])]),t._v(" "),a("h1",{attrs:{id:"reference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[t._v("#")]),t._v(" Reference")]),t._v(" "),a("ol",[a("li",[a("a",{attrs:{href:"https://www.icourse163.org/course/ZJU-200001#/info",target:"_blank",rel:"noopener noreferrer"}},[t._v("C 语言程序设计进阶 - 浙江大学 - 中国大学 MOOC"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://mooc.study.163.com/course/1000003015",target:"_blank",rel:"noopener noreferrer"}},[t._v("C++程序设计入门（上） - 北京邮电大学 - 网易云课堂"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://blog.csdn.net/Mind_V/article/details/78619163",target:"_blank",rel:"noopener noreferrer"}},[t._v("理解 C++中引用的底层实现"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://blog.csdn.net/zcyzsy/article/details/69788884",target:"_blank",rel:"noopener noreferrer"}},[t._v("C/C++编译的程序的内存分配"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);e.default=_.exports}}]);